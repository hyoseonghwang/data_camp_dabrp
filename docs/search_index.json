[
["index.html", "실무 빅데이터 분석을 위한 SQL과 R의 활용 CAMP 머리말", " 실무 빅데이터 분석을 위한 SQL과 R의 활용 CAMP 박찬엽 2017-08-20 머리말 이 책은 패스트캠퍼스의 데이터 사이언스 캠프 코스의 실무 빅데이터 분석을 위한 SQL과 R의 활용 CAMP의 수업용으로 제작되었습니다. 수업에 대해 더 자세히 알고 싶으신 분은 강사 인터뷰를 참고하세요. 책은 1. R의 IDE로 사실상 표준인 RStudio에 사용하기 좋은 기능 소개 2. 대부분의 에러 문제를 해결할 수 있는 기초 자료형에 대한 이해 3. 단순 반복 업무를 위한 for문과 apply류 맛보기 4. 데이터 원본/의존성의 개념과 SQL 문법 익히기 5. tidy data 개념과 dplyr+tidyr로 데이터 다루기 6. 보고용 차트를 위한 ggplot2 사용하기 7. 정기 보고서 자동 작성을 위해 knitr로 문서화하고 스케줄러로 자동화하기 8. shiny 패키지를 활용한 인터렉티프 웹 만들기 로 구성되어 있습니다. 많은 부분 rstudio-IDE-cheatsheet, R for Data Science, R Programming for Data Science, ggplot2-book, shiny-tutorial, Microsoft’s DAT204x, datacamp, programiz 등 을 참고하였습니다. 데이터 분석은 많은 단계들과 업무들로 나누어져 있습니다. 개인적으로 1. 데이터 확보 2. 데이터 정제 3. 분석 4. 시각화의 단계를 거친다고 생각합니다. 데이터란 사내에서 관리하고 있는 내부 데이터와 외부 인터넷에 공개되어 있는 데이터로 구분할 수 있습니다. 이런 데이터들 중 분석과 업무 목적에 맞는 데이터를 찾고, 활용하기 위에 확보하는 과정이 1단계 입니다. 분석 방법과 내용에 따라 확보된 데이터를 정리하거나 고쳐야 하는 일도 있습니다. 2 단계는 그것을 뜻합니다. 3 단계인 분석은 다양한 통계적 방법들을 통해 분석 목적을 이루는 것입니다. 4단계는 이렇게 이루어낸 결과물을 다른 사람에게 전달하기 위해 필요합니다. 이 책은 그 중 2단계인 정제와 4단계인 시각화에 초점이 맞춰져 있습니다. 계속 업데이트되므로 정보 챕터 하단에 업데이트 날짜를 확인하세요. 저작물 라이선스로 크리에이티브 커먼즈 라이선스 4.0(저작자 표시-비영리-변경 금지(BY-NC-ND))를 따릅니다. "],
["-.html", "시작하기 전에 0.1 데이터를 다루는 것 0.2 준비된 데이터 0.3 R과 Rstudio 0.4 git과 github 0.5 사용할 데이터베이스 0.6 환경 통일을 위한 도구 도커 0.7 정보", " 시작하기 전에 수업에서 사용하는 자료와 기반하는 생각들을 작성하고자 합니다. 0.1 데이터를 다루는 것 데이터 과학을 진행하는데에는 아래의 과정을 따릅니다. 공부를 위해 작성하는 자료니 만큼 자료를 생산하는 모든 코드는 숨기지 않고 같이 출력하겠습니다. library(&quot;visNetwork&quot;) nodes &lt;- data.frame(id = 1:7,label=c(&quot;1. 데이터 확보&quot;,&quot;2. 데이터 정제&quot;, &quot;3. 분석&quot;,&quot;데이터 핸들링&quot;,&quot;분석&quot;,&quot;결과 검증&quot;,&quot;4. 시각화&quot;), shape=&quot;box&quot;, font.size=25) edges &lt;- data.frame(from = c(1,2,3,4,5,3,6), to = c(2,3,7,5,6,4,4), dashes = c(F,F,F,F,F,T,F), length=100) visNetwork(nodes, edges, width = &quot;100%&quot;) %&gt;% visEdges(arrows =list(to = list(enabled = TRUE, scaleFactor = 1))) %&gt;% visLayout(randomSeed = -0.9261698*10000) 위 표는 해들리 위컴의 R for Data Science에 소개에 작성된 표이기도 합니다. 각각 Import, Tidy, Transform, Visualise, Model, Communicate라고 되어 있는 것을 제 상황에 맞게 각색하였습니다. 데이터 확보는 분석 목적에 맞는 데이터를 확보하는 것입니다. 보통 기업인의 입장에서 기업 내부에서 생산, 관리되고 있는 데이터, 외부에서 찾아야 하는 데이터, 없기 때문에 실험등을 통해 생산해야 하는 데이터 정도로 데이터를 나눌 수 있습니다. 이 때 내부 데이터를 사용하기 위해서는 두 가지 진입장벽이 있는데, 정책적인 접근 권한과 데이터를 다룰 줄 아는 능력입니다. 이 후 과정에서 데이터를 다루고, 그것으로 통계적 분석을 거쳐 필요한 결과물을 만드는 것에서 가장 보편적인 도구는 엑셀입니다. 데부분은 엑셀을 잘 사용하는 것으로 해결할 수 있습니다. 하지만 데이터가 커지고, 통계적 분석에 대한 수요가 높아지면서 R에 대한 관심으로 이어지고 있는 상황입니다. 데이터 정제는 해들리 위컴이 이야기한 Tidy data를 만드는 과정에 해당합니다. 이것을 위해서 Tidy data에 대해서 이야기 해야 하는데 그건 6장에서 다루려고 합니다. 간단하게는 컴퓨터에게 일을 시키기 좋은 상태로 데이터를 정리하는 것을 뜻합니다. 시간이 많이 드는 과정입니다. 분석은 데이터 핸들링, 분석, 결과 검증의 사이클을 따라 반복합니다. EDA나 데이터 이해를 위한 시각화 등이 이루어지고, 분석을 진행하며 얻는 결과물들을 만드는 과정이 진행됩니다. 이 때 개발에서 재현성의 개념을 가져오면 일을 좀 수월하게 할 수 있습니다. 여기서 말하는 재현성이란 연구 재현성보다는 실행 재현성을 뜻합니다. 실행 재현성은 어떤 결과물을 만드는 작업을 실행했을 때 다시 그것을 그대로 실행할 수 있는 것을 뜻합니다. 코드로 분석을 진행하는 것은 실행 재현성과 자동화에 매우 도움이 됩니다. 시각화는 앞서 반복적인 연구를 통해 알게된 사실을 다른 사람들에게 전달하는 과정 전체를 뜻합니다. 본 자료에서는 그래서 차트그리기 뿐만 아니라 Rmd를 활용한 문서화와 shiny를 활용한 앱 또한 시각화의 일부로써 다루고 있습니다. 위 4개 과정을 모두 다룰 줄 알면, 이제 도구를 다룰줄 알게 되는 것입니다. 연구나 분석 능력은 또 별개이지 않나 싶습니다. 이 책을 지속적으로 업데이트해서 연구와 분석, 데이터 과학에 대해 모두 다루는 책이 되기를 희망합니다. 0.2 준비된 데이터 수업을 위해 준비한 데이터는 고위 공직자 재산, 세종기업데이터를 크롤링한 깃헙 저장소, outbrain이 캐글에 공개한 사용자 웹 클릭 데이터 입니다. 웹 클릭 데이터는 특별히 sql로 데이터 핸들링을 하는 것에 대한 경험을 확보하기 위해서 찾아보았으며 전체 데이터는 약 100GB에 달하는 방대한 양입니다. 수업에서 실제로 다루기 보다는 다루어 보실 수 있게 데이터를 준비했습니다. 0.3 R과 Rstudio R은 여기에서 다운로드 할 수 있습니다. RStudio은 R을 사용하기 위한 IDE로 여러 편의성을 제공합니다. 자세한 사용법은 2장에서 소개합니다. 0.4 git과 github git은 코드의 버전관리 도구로 github의 인기에 힘입어 많은 개발자들이 사용하고 있습니다. 코드를 공개해 사용하면 무료이며, 이 책을 호스팅 하는 것처럼 각 아이디의 서브도메인을 무료로 사용할 수 있게 제공해줍니다. 수업에서는 자료 공유의 목적과 다른 사용자의 코드를 사용하는 수준으로 사용을 권장할 예정이며 깊게 공부하고 싶다면 한글자료가 많이 준비되어 있으니 참고하시기 바랍니다. 0.5 사용할 데이터베이스 오픈소스인 mariaDB을 사용하려고 합니다. 사용한 이유는 이 기사가 잘 설명하는 것 같습니다. 기본적으로는 전통적인 RDBMS이면서 많은 사람들이 사용하는 제품이기 때문입니다. 수업에 사용하는 모든 서비스, 패키지 등 일체는 모두 1. 오픈 소스이고 2. 많은 사용자를 확보해서 활발히 발달하고 있으며 3. 참고할 자료가 많은 것을 선택하려고 노력했습니다. 데이터베이스의 설치는 windows, mac을 참고해 주세요. mariaDB와 함께 인터페이스로 설치되는 HeidiSQL은 데이터베이스를 관리하는데 사용하는 GUI 툴입니다. 맥에서는 WINE을 통해서 사용할 수 있다고 하는데, Sequel Pro라는 도구도 있고, 설치를 소개하는 블로그가 있으니 참고하시기 바랍니다. 0.6 환경 통일을 위한 도구 도커 수업에서 다루지는 않지만 설치나 다른 환경 세팅으로 인한 시간 소모를 줄이기 위해서 docker를 사용할 수 있습니다. 수업 데이터가 준비되어 있는 마리아디비 도커 이미지를 준비하고 있습니다. 윈도우에서 하이퍼바이저(pro 버전 등에서 사용가능)가 있지 않은 경우 버추얼박스를 통해서 동작하므로 성능이 떨어질 수 있습니다. 0.7 정보 이 책의 소스는 여기에서 확인하실 수 있으며 아래 주어진 R 패키지(및 종속 패키지)의 버전으로 제작되었습니다. 저작물의 재현을 위해서 필요합니다. package * version date source backports 1.0.5 2017-01-18 CRAN (R 3.3.3) bookdown 0.3 2016-11-28 CRAN (R 3.3.3) codetools 0.2-15 2016-10-05 CRAN (R 3.3.3) devtools 1.12.0 2016-12-05 CRAN (R 3.3.3) digest 0.6.12 2017-01-27 CRAN (R 3.3.3) evaluate 0.10 2016-10-11 CRAN (R 3.3.3) htmltools 0.3.5 2016-03-21 CRAN (R 3.3.3) htmlwidgets 0.8 2016-11-09 CRAN (R 3.3.3) jsonlite 1.3 2017-02-28 CRAN (R 3.3.3) knitr 1.15.1 2016-11-22 CRAN (R 3.3.3) magrittr 1.5 2014-11-22 CRAN (R 3.3.3) memoise 1.0.0 2016-01-29 CRAN (R 3.3.3) Rcpp 0.12.10 2017-03-19 CRAN (R 3.3.3) rmarkdown 1.3 2016-12-21 CRAN (R 3.3.3) rprojroot 1.2 2017-01-16 CRAN (R 3.3.3) stringi 1.1.2 2016-10-01 CRAN (R 3.3.3) stringr 1.2.0 2017-02-18 CRAN (R 3.3.3) visNetwork * 1.0.3 2016-12-22 CRAN (R 3.3.3) withr 1.0.2 2016-06-20 CRAN (R 3.3.3) yaml 2.1.14 2016-11-12 CRAN (R 3.3.3) 이 책은 박찬엽이 일요일, 8월 20, 2017 오후 6:37:32 KST에 마지막으로 업데이트 했습니다. "],
["rstudio.html", "1 RStudio에 사용하기 좋은 기능 소개 1.1 RStudio 소개 1.2 구조와 기능들 1.3 프로젝트와 버전관리 1.4 도움말", " 1 RStudio에 사용하기 좋은 기능 소개 첫 수업은 RStudio를, 정확하게는 IDE에서 받을 수 있는 기능적 혜택들을 소개하려고 합니다. 1.1 RStudio 소개 1.1.1 IDE 란 IDE란 _통합 개발 환경_의 영어 줄임말로 텍스트 편집이외에도 디버깅, 컴파일, 배포등 개발의 위한 기능을 통합적으로 제공하는 프로그램을 지칭합니다. R 또한 개발언어의 일종으로 여러 IDE에서 사용할 수 있게 지원하고 있습니다. 1.1.2 Rstudio RStudio는 R을 처음 배우는 사람이 꼭 사용하는 IDE입니다. 다른 IDE에 비해 R 언어에 특화된 UI와 기능을 가지고 있으며 ggplot2, shiny, dplyr, httr 등 다양항 패키지를 왕성하게 만들고 있는 RStudio 팀이 직접 관리를 하기 때문에 문서도 많고, 우리나라 사용자층도 큰 편입니다. 특히 초보자부터 고급 사용자까지 필요한 많은 기능들을 GUI로 제공해 줘서 배울 수록 편리함이 늘어납니다. 1.1.3 다른 IDE 소개 IDE는 메모장 처럼 가벼운 Sublime Text부터 본격적인 Visual Studio까지 다양합니다. 개발자들이 많이 사용하는 IDE를 몇개 소개하겠습니다. Sublime Text는 꽤 오랫동안 사랑받은 텍스트 에디터 형 IDE입니다. 몇 가지 설정을 진행하면 R 코드도 실행하게 만들 수 있어 기존 개발자 분들 중 R을 공부하실 때 사용하는 경우가 종종 있습니다. Atom은 웹기술을 활용해서 어느 컴퓨터에서든 사용할 수 있는 범용성을 가진 IDE입니다. 가장 큰 강점은 plugin 제작이 쉬워서 사용자층이 폭발적으로 늘어나서 최근 많은 개발자들이 사용하고 있습니다. 대부분 웹 개발에 사용되며 오픈소스여서 비용이 발생하지 않는 장점이 있습니다. Vs Code는 Atom의 소스를 사용해서 마이크로소프트에서 수정한 IDE입니다. 여전히 오픈소스이며 큰 기업이 지원하는 만큼 기능 정리를 통한 최적화가 강점입니다. github 연동, 자동 업데이트 등 사용자 편의에 조금 더 중점을 두었습니다. Nuclide도 역시 Atom의 소스를 사용해서 페이스북이 만든 IDE입니다. 역시 오픈소스이며 remote Development를 기본 제공하는 것이 특징입니다. 페이스북 내에서 사용하기 위해 만들어졌다보니 웹개발에 조금더 최적화되어 있습니다. 마이크로 소프트가 레볼루션 R을 인수하면서 R 생태계 흡수를 위해 여러 기능들을 지원하는데요. RTVS이 대표적입니다. Visual Studio는 꽤 오랫동안 개발자들이 사용한 IDE입니다. IDE라는 말이 어울리게 수GB의 용량을 차지하고 매우 많은 기능들을 제공합니다. RTVS는 이런 Visual Studio에서 R을 사용할 수 있게 만든 기능으로 무료로 공개한 Visual Studio 2015 커뮤니티 버전에 설치하여 R의 사용환경을 구성할 수 있습니다. 1.2 구조와 기능들 RStudio는 처음부터 R을 지원하기 때문에 설치 이외의 작업을 할 필요 없고, 사용자층이 많아 사용법을 배우기도 좋고 검색도 쉽게 됩니다. 그래서 IDE를 RStudio로 선정하고 기능에 대해 설명하겠습니다. 여기 설명하는 기능은 RStudio만의 기능이 아니며 다른 IDE도 구성에 따라 같은 기능 혹은 더 나은 기능을 사용할 수 있습니다. 처음 실행하면 전부 4개면(pane)으로 구성되어 있으며 각부의 이름 은 위 그림과 같습니다. source 창은 코드와 그 순서를 저장하는 script를 보여주는 곳입니다. console 창은 R의 엔진과 대화(!)를 할 수 있는 공간합니다. 명령어를 입력하면, 바로 콘솔창이 대답을 줍니다. console 창에 직접 입력을 해도 되고, source 창의 코드를 여러 방법을 통해서 console 창으로 전달해서 결과를 받을 수 도 있습니다. environment 창(이하 env 창)은 console 창에 입력이 되어서 현재 메모리에 기록되어 있는 상황을 보여주는 곳입니다. R은 변수가 메모리에 저장되어 있는 상태여야만 변수로써 사용할 수 있습니다. 그래서 env 창에서는 그렇게 메모리에 저장되어 있는 변수들의 이름과 내용을 확인할 수 있습니다. help 창은 window 탐색기와 같은 files, 차트 결과를 보여주는 plots, 설치나 불러온 패키지 상태를 보는 packages, 도움말을 보는 help 등 다양한 창으로 구성되어 있습니다. 아래에서 하나하나 중요한 기능을 보겠습니다. 1.2.1 source 창 source창 source 창에서 가장 중요한 기능은 ctrl+enter 입니다. ctrl+enter는 커서가 위치한 줄의 코드를 console 창으로 전달해서 R 엔진이 결과물을 주도록 하는 단축키입니다. 코드를 드래그해서 선택한 만큼의 코드를 실행할 때도 같은 단축키를 사용합니다. File &gt; New File 로 들어가시면 여러 종류의 파일을 만들 수 있는데, 각 파일에 따라 다른 추가 기능들이 나오기도 합니다. 1.2.2 console 창 console 창은 실제로 실행이 이루어지는 곳입니다. 여기서 가장 중요한 것은 아래 보이는 workding directory위치 입니다. R도 다른 개발 언어들 처럼 R 엔진이 실행되는 폴더의 위치가 지정되어 있습니다. R 엔진이 실행되는 위치를 workding directory라고 합니다. 그래서 파일을 불러오거나 하는 명령어는 workding directory를 기준으로 실행이 됩니다. 폴더의 위치를 입력하는 양식을 보통 경로라는 단어를 사용하고, 편의에 따라 절대경로와 상대경로를 사용합니다. workding directory가 문제가 되는 경우는 상대경로일 때 입니다. 상대경로는 . 이라는 표시를 현재 폴더라는 뜻으로 사용합니다. workding directory를 잘 모르고 실행하다 문제가 생기면 가장 해결하기 좋은 방법은 절대경로를 사용하는 것입니다. 혼자 사용하면 문제가 없지만 같이 사용하거나 다른 환경에서 사용해야 할 경우는 매번 경로를 수정해야 되는 문제가 생깁니다. 그렇다면 상대경로로 작성하되 동작방식을 하는게 중요합니다. 보통은 파일을 실행하는 위치로 결정되는데, console의 경우 처음 언어 엔진을 실행한 위치로 결정되기도 합니다. 처음 시작하시는 분들이 크게 하는 실수는 help 창 부분에서 사용하는 files에서 보는 위치로 workding directory가 계속 따라 바뀌는 것으로 오해하는 것입니다. files 창 내에서 실행하는 것 이외의 실행들은 대부분 위 사진의 위치에 있는 workding directory에서 실행된다고 알고 계시는 것이 중요합니다. 1.2.3 environment 창 env창 environment 창은 Environment 창과 History 창, git을 사용한다면 git 창이 보입니다. Build 창이 보일때가 있는데 이것은 package를 만들거나 소스를 가져와 컴파일할 때 사용하는 창으로 사용할 일이 있으시면 R packages을 참고하세요. env 창은 위에서 설명한 것 처럼 메모리에 등록한 변수들을 각 이름과 내용에 대해 간략히 보여줍니다. console 창에 ls()를 입력하면 나타나는 등록된 변수들의 이름과 같습니다. HIstory 창은 console 창에 입력한 순서대로 기록을 해주는 공간입니다. 이 곳에서는 명령어를 클릭한 후 To Console과 To Source를 사용할 수 있습니다. 어떻게 동작하는지는 한번 실행해봐주세요. git 창은 git의 기능을 GUI로 사용할 수 있게 제공합니다. commit, pull, push, log 등의 기능을 사용할 수 있습니다. 다음 장에서 git과 github에 대해 간단히 사용하는 법을 설명드리겠습니다. 1.2.4 help 창 help 창은 다른 곳에 비해 다양한 기능을 수행합니다. files는 윈도우에서의 탐색기와 같이 파일들을 찾아볼 수 있습니다. 조금 불편하긴 하지만 이름 바꾸기, 복사, 이동 등을 할 수 있습니다. 그리고 메모리에 올릴 데이터(csv, xlsx 등)를 왼쪽 클릭하면 아래 화면과 같이 view와 import를 할 수 있습니다. 물론 저는 명령어로 불러오는 것을 권장합니다. plot 창은 plot과 그 계열의 차트나 그림을 그리는 명령어의 결과물이 표시되는 곳입니다. 전에 그렸던 결과물이 계속 저장되서 전에 그렸던 그림을 다시 볼 수 도 있습니다. packages 창은 현재 시스템에 설치되어 있는 package들을 리스트로 보여주고, 현재 불러와져서 사용할 수 있는 package들을 체크 박스로 표시해줍니다. install, update 버튼도 있습니다. Packrat은 패키지 의존성 관리 도구로써 패키지들을 프로젝트 별로 독립적으로 관리해서 다른 환경에서 사용할 때 최대한 실행 환경을 유지할 수 있게 도와주는 역할을 합니다. help 창은 help(함수명), ?함수명 같이 함수의 설명서를 요구하는 명령어를 console 창에 입력했을 때 설명 문서를 보여주는 곳입니다. 각 세부적인 기능에 대해 계속 업데이트 하겠습니다. 1.3 프로젝트와 버전관리 RStudio는 사용 화면에 대화형 console 창을 항상 켜놓고 있는 형태의 IDE 입니다. 그렇다 보니 RStudio에서 직접 프로젝트라는 기능을 제공합니다. 프로젝트란 어떤 분석 프로젝트 단위 하나를 의미하며 그 프로젝트를 관리하는 것을 도와주는 도구들을 제공합니다. 1.3.1 폴더와 프로젝트 가장 간단하게는 .proj 파일을 생성하는 것입니다. 왼쪽 위에 File &gt; New Project &gt; New Diractory &gt; Empty Project 를 선택하신 후 폴더 이름을 입력하고 프로젝트를 만듭니다. 그러면 프로젝트 이름과 같은 폴더가 만들어 지고 그 안에 프로젝트이름.porj파일이 함께 생성됩니다. .proj 파일은 Tools &gt; Project Options에서 조절할 수 있는 정보들을 저장하고 있습니다. 그리고 더블 클릭을 통해 프로젝트을 오픈하면서 RStudio를 실행시킬 수 있습니다. 또한 workding directory를 프로젝트 폴더로 자동 지정해 줍니다. 프로젝트 내의 코드 작업물을 모두 상대경로를 편하게 사용할 수 있게 해줍니다. 다른 사람들에게 공유할 때도 폴더 째로 공유하고, .proj파일로 실행하면 다른 곳에서도 어느 정도 코드가 동작하는데 경로나 설정을 걱정하지 않을 수 있습니다. 1.3.1.1 재현성을 위한 패키지 의존성 관리도구 Packrat 각 프로젝트에서 사용하는 패키지를 프로젝트 폴더내에 관리할 수 있게 해줌으로써 더욱 코드 재현성을 보장하는 관리도구입니다. Tools &gt; Project Options 하위에 옵션이 있으며 체크박스를 체크하는 것으로 사용할 수 있습니다. 처음부터 프로젝트를 만들 때 선택할 수도 있습니다. 자세한 안내는 여기를 참고하세요. 1.3.2 버전관리도구 git 1.3.2.1 버전관리도구란 git은 현재 개발자들에게 가장 인기있는 버전관리도구 입니다. 버전관리도구란 파일의 변경사항을 저장하는 도구로 word 같은 곳에서 Ctrl+z 같은 것(되돌리기)을 수행하기 위해 변경이 생길때 마다 저장하는 것과 비슷한 기능을 수행합니다. 다른 점이라면 프로젝트와 같이 폴더별로 관리된다는 점, 변경상태에 대해서 추적할 파일을 git에게 알려주는 행위를 해야 한다는 점, 저장을 일부러 해야 한다는 점 정도가 차이점이라고 볼 수 있습니다. 각각 git init, git add, git commit 명령어에 대응되는 개념입니다. 1.3.2.2 git으로 버전 관리하기 git init은 명령을 실행한 위치의 폴더가 git이 관리하는 프로젝트 폴더임을 선언하는 명령어입니다. 위 그림처럼 .git이라는 폴더가 생기는데 여기에 버전관리를 위한 여러 정보들을 저장합니다. 앞에 .이 붙은 폴더는 unix 계열 OS에서 숨김파일을 뜻하고, 윈도우에서도 숨김 파일 옵션으로 생성됩니다. 숨김 파일을 보는 옵션을 설정하시면 확인하실 수 있습니다. 어쨌든 git을 사용하는 첫번째 방법을 배웠습니다. 1.3.2.3 git이 이해하는 세 가지 상태 git은 폴더 내에 있는 파일들을 전부 3가지 상태로 구분합니다. 그것은 tracked, modified, staged입니다. 각각 살펴보겠습니다. tracked는 말 그대로 파일이 추적되고 있는 상태다라는 뜻합니다. git이 추적할 파일을 지정해 주는 git add [파일 or 폴더명]을 통해 untracked 파일이 tracked 파일로 상태가 변경되고 git의 추적이 시작됩니다. 과거 용량 등의 관리가 중요할 때 의 기능으로 이해하고 있으며 최근의 git을 사용하기 위한 추가적인 지원도구들은 대부분 자동으로 git add .을 진행하여 폴더내의 모든 파일을 계속 tracked 상태를 유지해 줍니다. tracked 상태의 파일을 수정하면 modified 상태가 됩니다. track 이 시작되면 파일의 track 시작할 때의 상태를 저장해 두는데, 그것과 비교해서 다른 점이 발생하면 modified 상태로 git은 인지하고 있습니다. 하지만 아직 git이 달라진 점을 저장하지 않습니다. 달라진 것만 알고 있는 상태입니다. modified 상태의 파일은 아직 commit할 수 없습니다. stage 위에 올려서 commit 할 수 있는 상태로 만들어야 합니다. 즉, staged 상태는 commit을 할 대상 파일로 지정되었다는 뜻입니다. commit이란 처음 생성된 상태나 이전 commit된 상태와 현재 상태를 비교해서 달라진 점을 저장하는 것을 뜻합니다. 이 때 git은 달라진 점만 저장합니다. 저장하면서 주석과 같은 기능을 하는 commit message를 작성해 둘 수 있습니다. 이 메세지를 통해서 코드에서 주요하게 달라진 점이 무엇인지를 파악할 수 있습니다. 이렇게 git은 코드의 상태를 정의하고, commit을 통해 변경되는 지점들을 저장합니다. 그럼 git checkout을 이용해 저장된 commit의 위치로 자유롭게 움직일 수 있습니다. 1.3.2.4 로컬과 리모트 git은 협업을 위한 도구이기도 합니다. 그래서 직접 작업하는 프로젝트 공간인 local과 다른 사람들과 공유하기 위한 공동 프로젝트 공간인 remote가 있습니다. 모두 repository(줄여서 repo) 또는 저장소라는 표현을 씁니다. remote에 git으로 관리되고 있는 프로젝트가 있다고 생각해 봅시다. 그 remote repo의 주소를 가지고 local에 git clone [remote repo 주소]명령어로 복사를 합니다. 그리고 local에서 새로운 파일도 만들고 코드도 작성한 후에 위에서 말한 것 처럼 git add로 파일을 등록하고, git commit을 통해 변경 사항들을 저장합니다. 이제 local에 저장된 변경부분을 remote에 기록을 해야 하는데 git push라고 합니다. 1.3.3 github github은 현재 가장 인기있는 git remote repository service입니다. 많은 분들이 이렇게 헷갈리시는데, github는 정확히 git과 같은 것이 아닙니다. github은 git에서의 remote repo를 저장할 수 있는 공간을 제공하는 서비스입니다. 비슷한 서비스로는 bitbuket, gitlab 등이 있습니다. git과 비슷한 다른 버전관리 도구를 지원하기도 합니다. github은 git과 달리 remote repo끼리 clone과 push와 같은 기능을 수행하는 새로운 옵션을 제공합니다. 바로 fork와 pull request입니다. SNS처럼 좋아요를 의미하는 star도 있습니다. fork는 공유하기와 비슷한데, 자신의 remote repo에 다른 사람의 remote repo를 복사해 오는 것입니다. git clone과 비슷합니다. github내의 remote repo끼리 동작하는 것이기 때문에 remote repo와 local repo가 상호작용하는 동작과 다른 명령어를 사용합니다. pull request는 fork로 연결되어 있는 remote repo에 자신의 remote repo에 있는 코드를 pull 해가라고 요청하는 것입니다. fork를 한 후 수정한 코드를 원래 주인의 remote repo에 적용하는 것을 요청하는 명령입니다. 위와 같은 과정을 통해 github이 동작합니다. github은 git의 인기와 공개 저장소의 무제한 제공으로 세계에서 가장 인기있는 서비스가 되었고, 대부분의 오픈소스가 저장되고 개발되는 공간이 되었습니다. 오픈소스는 라이선스를 잘 지킨다면 소스코드를 사용해도 좋다고 선언한 코드들입니다. 많은 분들이 자신들의 코드를 공개하고, 결과물을 공유합니다. RStudio 또한 코드를 github에 공개하고 관리하고 있습니다. RStudio는 조금 복잡한 라이선스로 선언해서 편하게 사용할 수 있는 것은 아니지만 이렇게 코드를 공개하고 라이선스를 선언한 것을 오픈소스라고 합니다. 1.3.4 github과 패키지 생태계 R-core 팀이 관리하는 패키지 배포 서버인 cran은 매우 엄격한 패키지 사전 검열을 합니다. 그렇기 때문에 console에서 install.packeges() 한번에 편하게 패키지를 설치하고 사용할 수 있는 것입니다. 최근에는 사전 검열을 통과하기 전 버전의 패키지들이 코드 관리를 위해 github에 저장소를 운영하기도 합니다. github은 인기있는 저장소이기 때문에 구글 검색을 통해 사용자들이 유입되기 좋은 곳입니다. 특히 패키지 운영을 위한 홈페이지, wiki, readme 파일 관리등의 기능을 충분히 지원하는 등 좋은 점이 많습니다. 많은 R 패키지 개발자들도 코드 관리를 github에서 하고 있습니다. 최근에는 개발 버전은 github에, 안정화 버전은 cran에 등록해서 사용할 수 있게 하는 문화가 자리잡혀 있습니다. 1.4 도움말 cran에 등록된 패키지들은 모두 도움말이 충분히 작성되어 있습니다. Vignette라는 세부 패키지 설명이나 아예 블로그 등에서 패키지 사용법이나 작업 순서들을 설명한 패키지도 있습니다. 모두 검색을 통해서 찾아야 되긴 하지만 최소한의 설명서가 내장되어 있으니 그 것을 먼저 확인하는 것이 좋습니다. 도움말은 ?함수명이나 help(함수명)으로 실행할 수 있습니다. ?함수명 "],
["data-type.html", "2 대부분의 에러 문제를 해결할 수 있는 기초 자료형에 대한 이해 2.1 기초 자료형 2.2 벡터 2.3 메트릭스 2.4 팩터 2.5 리스트 2.6 데이터프레임 2.7 날짜", " 2 대부분의 에러 문제를 해결할 수 있는 기초 자료형에 대한 이해 자료형에 대해 알고 있는 것과 자료형을 파악하는 것은 매우 중요합니다. 함수가 입력 데이터로 사용이 가능한 데이터를 입력 데이터로 지정해 주어야 실행이 되기 때문인데요. 많은 분들이 여기에서 문제가 발생합니다. 특히 작업을 진행하면서 기대하지 않은 자료형으로 중간 결과물이 나오는 경우에는 이후에 생기는 문제에 대해서 이해하기 어려울 수 있습니다. 그렇기 때문에 기본 R에서 제공하는 자료형에 대해서 공부해 두는 것은 대부분의 함수가 사용하는 데이터의 형식을 공부하는 것과 같습니다. 물론 패키지마다 자체 자료형을 정의하기도 합니다. 하지만 지금 기초 자료형을 공부하면서 새로운 자료형을 파악하는 방법을 자연스럽게 배울 수 있을 거라 생각합니다. 자료형을 파악하는 방법은 class 함수를 사용하는 것입니다. x &lt;- 1 class(1) #&gt; [1] &quot;numeric&quot; class(x) #&gt; [1] &quot;numeric&quot; class(&quot;x&quot;) #&gt; [1] &quot;character&quot; ?class를 입력해서 class 함수에 대해서 파악해 보세요. 위에 class 함수의 결과로 나오는 것이 자료형의 종류입니다. numeric은 숫자를, character는 글자를 뜻합니다. 이제 아래에서 하나하나 확인해 보겠습니다. 기초 자료형에 대해서 MS의 edX 강의, datacamp, r-tutor의 내용을 참고했습니다. 2.1 기초 자료형 2.1.1 논리형 logical logical(로지컬) 자료형은 기다 아니다 같이 True, False를 표현하기 위해 만들어진 자료형입니다. R에서는 각각 두 가지 표현법이 있습니다. TRUE #&gt; [1] TRUE class(TRUE) #&gt; [1] &quot;logical&quot; T #&gt; [1] TRUE class(T) #&gt; [1] &quot;logical&quot; FALSE #&gt; [1] FALSE class(FALSE) #&gt; [1] &quot;logical&quot; F #&gt; [1] FALSE class(F) #&gt; [1] &quot;logical&quot; 언어에 따라 True, False를 채택하는 경우도 있습니다만 R의 경우 위와 같이 전부 대문자인 글자를 logical 자료형으로 인식합니다. 이렇게 class 함수를 이용해서 자료형이 무엇인지 파악하는 것도 중요하지만, 조건문 등을 통해서 일을 자동적으로 수행하게 시키기 위해서는 class 같이 결과값이 다양한 것 보다는 logical 자료형으로 결과가 나오는 것이 앞으로 배우게 될 if 문 등에 조건으로 사용하기 좋습니다. 아래와 같은 is.logical 함수는 괄호안의 데이터가 logical 자료형이 맞는지를 물어보는 함수 입니다. 다른 자료형도 대부분 is.자료형이름을 함수로 사용할 수 있습니다. test &lt;- TRUE is.logical(test) #&gt; [1] TRUE is.logical(TRUE) #&gt; [1] TRUE is.logical(&quot;test&quot;) #&gt; [1] FALSE test &lt;- &quot;1&quot; is.logical(test) #&gt; [1] FALSE R Studio에서는 함수의 자동완성 기능을 제공합니다. is.을 입력해서 다양한 자료형을 확인하는 명령어를 구경해보세요. 2.1.2 숫자형 numeric numeric(뉴메릭) 자료형은 그 영어 뜻이 숫자의인 것 같이 숫자를 표현하는 자료형입니다. 물론 복소수 같이 다른 여러 표현들도 사용할 수 있습니다만, R에서 숫자는 보통 numeric 자료형으로 처리합니다. 2 #&gt; [1] 2 class(2) #&gt; [1] &quot;numeric&quot; is.numeric(2) #&gt; [1] TRUE numeric은 소수점 이하 값을 가지는 숫자도 포함합니다. 2.5 #&gt; [1] 2.5 class(2.5) #&gt; [1] &quot;numeric&quot; is.numeric(2.5) #&gt; [1] TRUE 숫자를 표현하는 자료형으로 integer도 있습니다. 영어 뜻 그대로 정수를 표현하는 자료형인데요, 소수점이 없는 숫자를 표현할 때 사용합니다. R에서는 integer로 바로 인식시키기 위해서 정수인 숫자 뒤에 L(대문자 엘)을 붙여서 표현합니다. 2L #&gt; [1] 2 class(2L) #&gt; [1] &quot;integer&quot; is.numeric(2L) #&gt; [1] TRUE is.integer(2L) #&gt; [1] TRUE integer는 numeric에 비해 차지하는 메모리가 적으며 때문에 연산이 좀 더 빠르다는 장점이 있습니다. 2.1.3 글자형 character character(캐릭터) 자료형은 그 영어 뜻이 문자인 것 같이 글자를 표현하는 자료형입니다. R에서는 변수와 글자를 구분하기 위해서 글자의 앞뒤에 &quot;를 붙이는데요. '도 같은 역할을 합니다. 그래서 &quot;나 ' 사이에 있는 것은 모두 글자, 즉 character로 인식합니다. &quot;2&quot; #&gt; [1] &quot;2&quot; class(&quot;2&quot;) #&gt; [1] &quot;character&quot; is.numeric(&quot;2&quot;) #&gt; [1] FALSE is.character(&quot;2&quot;) #&gt; [1] TRUE 한글도 됩니다. is.character(&quot;한글&quot;) #&gt; [1] TRUE 심지어 &quot; 사이에 있는 ', ' 사이에 있는 &quot;도 글자로 인식합니다. 이걸 이용해서 글자내에 &quot;나 '가 들어가야 할 경우, 안에 들어가지 않는 것을 글자로 인식시키기 위한 표시로 사용하기도 합니다. &quot;&#39;&quot; #&gt; [1] &quot;&#39;&quot; is.character(&quot;&#39;&quot;) #&gt; [1] TRUE &#39;&quot;&#39; #&gt; [1] &quot;\\&quot;&quot; is.character(&#39;&quot;&#39;) #&gt; [1] TRUE 이렇게 다른 자료형의 기반이 되는 기초 자료형 3개에 대해 알아보았습니다. 이 각각은 지금까지 데이터가 한 개인 경우였습니다. 그렇다면 이 자료형들이 모여 이루는 새로운 자료형에 대해서 알아보겠습니다. 2.2 벡터 2.2.1 하나의 기초 자료형만으로 구성된 1차원 데이터 집합 vector(벡터) 자료형은 가장 간단하게 하나의 자료형에 해당하는 데이터들의 1차원적인 집합입니다. vector를 만드는 가장 간단한 함수는 c입니다. ?c를 실행해서 내용을 한 번 읽어주세요. vec_char &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) vec_char #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; class(vec_char) #&gt; [1] &quot;character&quot; is.vector(vec_char) #&gt; [1] TRUE is.character(vec_char) #&gt; [1] TRUE vec_char는 character이기도 하면서 vector입니다. 그럼 이번엔 숫자 벡터를 한번 만들어 보겠습니다. vec_num &lt;- c(1,2,3,4,5) vec_num #&gt; [1] 1 2 3 4 5 class(vec_num) #&gt; [1] &quot;numeric&quot; is.vector(vec_num) #&gt; [1] TRUE is.numeric(vec_num) #&gt; [1] TRUE 이번엔 vec_num이 numeric이기도 하면서 vector입니다. 마지막으로 논리 벡터를 만들어 볼까요. vec_logi &lt;- c(T,T,T,F,F,T) vec_logi #&gt; [1] TRUE TRUE TRUE FALSE FALSE TRUE class(vec_logi) #&gt; [1] &quot;logical&quot; is.vector(vec_logi) #&gt; [1] TRUE is.logical(vec_logi) #&gt; [1] TRUE 지금까지 살펴본 바에 따르면 vector라는 사실은 class로 파악할 수 없고, is.vector로 확인할 수 있습니다. 사실 파악할 수 없다보다는 파악할 필요가 없습니다. vector는 한 번에 같이 처리할 수 있는 데이터를 묶어둔 것이기 때문에 한 vector로 묶인 데이터들은 모두 자료형이 강제로 같게 만들어 집니다. 아래와 같이 다양한 시도를 해서 강제로 자료형이 통일되게 저장되는 것을 확인해 보세요. vec_test1 &lt;- c(1,2,3,&quot;test&quot;) vec_test1 #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;test&quot; class(vec_test1) #&gt; [1] &quot;character&quot; 이렇게 vector는 하나의 기초 자료형만으로 구성된 1차원 데이터 집합인 것을 알게 되었습니다. 그럼 이제 vector에서 일부의 데이터만 불러오는 방법을 알아보겠습니다. 2.2.2 vector에서 일부 데이터 불러오기 데이터를 모아 놓은 것은 좋은 전략이지만 그 중 일부를 자유롭게 사용할 수 있을 때 더욱 빛을 발하는 것 같습니다. vector는 같은 종류의 데이터를 한 줄로 늘어뜨려 놓은 것으로 상상하시면 좋을 것 같은데, 왜냐면 위치로 데이터의 일부를 선택하기 위해서 입니다. 컴퓨터 언어에서 무엇을 언급하는 방법은 두 가지가 있습니다. 하나는 임의의 이름으로 지정된 주소값 자체를 언급하는 것이고, 다른 하나는 그 주소값에 이름을 부여해서 그 이름을 부르는 것입니다. 정확한 비유는 아닙니다만, vector에서 특정 위치에 있는 값을 부르는 것은 위치의 주소값이나 지정해둔 이름으로 값을 부르는 것과 비슷합니다. 값의 순서라고 볼 수 있는 주소값을 index라고 합니다. R에서 index를 사용하는 방법은 [ ](대괄호)를 변수뒤에 붙여서 사용합니다. vec_ind &lt;- c(&quot;b&quot;,&quot;a&quot;,&quot;ab&quot;,&quot;b&quot;,&quot;o&quot;,&quot;ab&quot;) vec_ind[1] #&gt; [1] &quot;b&quot; 위에서 지정해둔 이름으로 값을 부르는 방법이 있다고 했습니다. 그러면 우선 vector의 값에 이름을 부여하는 방법을 살펴보겠습니다. 새롭게 살펴볼 명령어는 names입니다. ?names를 실행해서 살펴보세요. blood_type1 &lt;- c(bob = &quot;A&quot;, sam = &quot;B&quot;, john=&quot;O&quot;,jim=&quot;AB&quot;,tom=&quot;A&quot;) blood_type1 #&gt; bob sam john jim tom #&gt; &quot;A&quot; &quot;B&quot; &quot;O&quot; &quot;AB&quot; &quot;A&quot; names(blood_type1) #&gt; [1] &quot;bob&quot; &quot;sam&quot; &quot;john&quot; &quot;jim&quot; &quot;tom&quot; 위의 첫번째 방법은 처음 vector를 만들 때 부터 이름을 짓고 시작하는 것입니다. =를 기준으로 왼쪽이 이름, 오른쪽이 이름에 해당하는 값입니다. 그럼 다른 방법을 보겠습니다. blood_type2 &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;O&quot;,&quot;AB&quot;,&quot;A&quot;) blood_type2 #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;O&quot; &quot;AB&quot; &quot;A&quot; names(blood_type2) #&gt; NULL blood_type2_name &lt;- c(&quot;bob&quot;, &quot;sam&quot;, &quot;john&quot;, &quot;jim&quot;, &quot;tom&quot;) blood_type2_name #&gt; [1] &quot;bob&quot; &quot;sam&quot; &quot;john&quot; &quot;jim&quot; &quot;tom&quot; names(blood_type2) &lt;- blood_type2_name blood_type2 #&gt; bob sam john jim tom #&gt; &quot;A&quot; &quot;B&quot; &quot;O&quot; &quot;AB&quot; &quot;A&quot; names(blood_type2) #&gt; [1] &quot;bob&quot; &quot;sam&quot; &quot;john&quot; &quot;jim&quot; &quot;tom&quot; names 함수가 vector의 이름을 보여주는 함수이기도 하면서 값을 지정받을 수 있는 변수의 기능도 합니다. names(blood_type2) 전체가 하나의 변수로 동작하는 것이지요. 그래서 처음 선언한 vector에 이름이 없는 것을 확인하고 새롭게 이름에 해당하는 변수 blood_type2_name을 선언한 후에 names(blood_type2)에 선언해줌으로써 이름을 작성했습니다. 두번째 방법을 보면 언제든 새롭게 이름을 지정해 줄 수 있음을 알 수 있습니다. 원래 내용으로 돌아가서, 그럼 이제 이름으로 그 위치에 해당하는 값을 출력해 보겠습니다. blood_type1 &lt;- c(bob = &quot;A&quot;, sam = &quot;B&quot;, john=&quot;O&quot;,jim=&quot;AB&quot;,tom=&quot;A&quot;) blood_type1[bob] 조금 이상합니다. Error: object 'bob' not found라고 하면서 동작하질 않네요. Error 메세지는 함수가 작동하는데 문제가 있어서 실행이 되질 않았다는 뜻입니다. (참고로 Warning은 실행은 됬지만 기대하는 결과가 아닐 수 있으니 확인해보라는 뜻입니다.) object는 지금까지 한글로 변수라고 불렀습니다. 그럼 변수인 bob이 없다는 에러가 발생한 겁니다. 글자형에서 R에서는 변수와 글자를 구분하기 위해서 글자의 앞뒤에 &quot;를 붙인다고 했습니다. 그렇다면 blood_type1[bob]에서 bob의 앞뒤에 &quot;표시를 하지 않았기 때문에 R이 변수로 인식한 듯합니다. 그럼 &quot;로 묶어서(앞뒤에 표시해서) 다시 실행해 보겠습니다. blood_type1 &lt;- c(bob = &quot;A&quot;, sam = &quot;B&quot;, john=&quot;O&quot;,jim=&quot;AB&quot;,tom=&quot;A&quot;) blood_type1[&quot;bob&quot;] #&gt; bob #&gt; &quot;A&quot; 이제 원하는 결과가 나왔습니다. 이런 문법에 대해서는 규칙을 정확히 이해하는 것도 중요하지만 계속 console에 입력해보면서 테스트를 하는 것이 매우 중요합니다. 그렇게 하면 자주 사용하는 것은 익숙해지고, 기억이 흐릿한 것은 확인해가며 코드를 작성할 수 있게 됩니다. 더 확인해봐야 할 것이 있습니다. 지금까지 한 개만 불러오는 것을 했는데, 여러 개를 동시에 해도 되는지를 확인해 보겠습니다. blood_type1 &lt;- c(bob = &quot;A&quot;, sam = &quot;B&quot;, john=&quot;O&quot;,jim=&quot;AB&quot;,tom=&quot;A&quot;) blood_type1[c(&quot;bob&quot;,&quot;john&quot;)] #&gt; bob john #&gt; &quot;A&quot; &quot;O&quot; 여러 개도 가능합니다. 여러 개를 지정하기 위해 c함수를 함께 사용한 것에 주목해 주세요. c로 이름을 묶어서 사용하지 않으면 어떻게 되는지 확인해 보세요. blood_type1 &lt;- c(bob = &quot;A&quot;, sam = &quot;B&quot;, john=&quot;O&quot;,jim=&quot;AB&quot;,tom=&quot;A&quot;) blood_type1[&quot;bob&quot;,&quot;john&quot;] Error in blood_type1[&quot;bob&quot;, &quot;john&quot;] : incorrect number of dimensions이라는 Error를 보셨으면 맞게 동작하는 것입니다. 메세지를 한번 잘 보겠습니다. dimension은 차원이라는 뜻으로 제가 vector는 1차원 데이터 집합이라는 표현을 썼었습니다. 그렇다면 차원이 맞지 않게 요청이 되었다는 뜻입니다. R은 [ ]안에서 ,(쉼표)는 차원을 구분하는 것으로 인식합니다. 예를 들어 [ , , , ]라고 하면 4차원 데이터를 뜻한다고 할 수 있습니다. 그렇기 때문에 blood_type1[&quot;bob&quot;,&quot;john&quot;]은 저희가 의도하지 않는 방식으로 R이 이해한 것입니다. R이 이해하는 대로 해석하면 첫번째 차원은 이름이 ’bob’인 데이터를, 두번째 차원은 이름이 ’john’인 데이터를 불러옴이 됩니다. 하지만 우리는 첫번째 차원에서 이름이 ’bob’인 데이터와 이름이 ’john’인 데이터를 불러옴을 실행하고 싶기 때문에 같은 차원에서 두 개의 이름을 사용했다는 것을 R에게 알려줘야 합니다. 그래서 c 함수를 사용해서 이름을 묶어, 여러 데이터를 불러오는 이름을 사용할 때 vector를 사용한 것입니다. 이 방법은 차원이 늘어나거나 하더라도 같은 문법을 사용합니다. 그럼 이제 2차원 데이터 집합인 matrix를 살펴보겠습니다. 2.3 메트릭스 2.3.1 vector의 2차원 확장 matrix는 간단하게 1차원의 vector를 2차원으로 확장한 것입니다. 여기서 2차원이란 1차원 vector가 두 줄이 생겼다는 것이 아니라 행과 열로 2차원을 표현하게 됩니다. matrix는 많이 보시는 엑셀 시트와 같은 형태를 띕니다. 차원의 의미가 여러 가지가 가능하겠습니다만, 지금의 차원은 데이터를 표현하는 축의 갯수라고 이해하시면 좋을 것 같습니다. 소개해야 할 자료형 중에 array가 있는데 배열이라는 뜻입니다. vector는 1차원 array의 특별한 이름이고, matrix는 2차원 array의 특별한 이름입니다. 3차원 이상 부터는 전부 n차원 array라고 합니다. 그래서 vector와 matrix, array는 앞서 vector에서 확인했던 문법적 규칙과 모두 같은 규칙을 따릅니다. 그럼 이제 matrix를 한번 만들어 보겠습니다. matrix(1:6, nrow = 2) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 matrix(1:6, ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 matrix(1:6, nrow = 2, byrow = TRUE) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 위에서 1:6은 1부터 6까지의 숫자 벡터를 뜻합니다. c(1,2,3,4,5,6)과 같습니다. row는 행을, col은 column의 줄임말로 열을 나타내구요. byrow옵션이 TRUE면 row방향으로 먼저 벡터를 나열하라는 뜻입니다. matrix는 행열의 크기를 지정하기 때문에 지정된 크기보다 작은 양의 데이터를 선언할 때 어떻게 동작할 것인지 정해져 있습니다. matrix(1:3, nrow = 2, ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 2 #&gt; [2,] 2 1 3 matrix(1:4, nrow = 2, ncol = 3) #&gt; Warning in matrix(1:4, nrow = 2, ncol = 3): 데이터의 길이[4]가 열의 개수[3] #&gt; 의 배수가 되지 않습니다 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 1 #&gt; [2,] 2 4 2 첫번째 명령에서는 부족한 갯수만큼 있던 것을 다시 사용해서 자동으로 채워줬네요. 두번째 명령에서도 같은 방식으로 동작한 것 같은데 Warning 메세지가 나왔습니다. 행의 갯수의 약수거나 배수이지 않다는 것을 알려줌으로써 의도적인 행동인지 확인할 수 있게 도와줍니다. 결과를 확인해보면, 4개까지 사용하고 다시 처음부터 1, 2를 사용하면서 행열의 크기만큼 데이터를 채웠습니다. Warning이 나오면 확인해보면 좋겠네요. 행열의 모양을 배우면서 이제 cbind와 rbind를 확인해 보겠습니다. cbind는 열 방향으로 묶는다.라는 의미이구요. rbind는 행 방향으로 묶는다는 뜻입니다. 아래 코드로 어떻게 행열의 모양이 달라지는지 확인해 보세요. cbind(1:3, 1:3) #&gt; [,1] [,2] #&gt; [1,] 1 1 #&gt; [2,] 2 2 #&gt; [3,] 3 3 rbind(1:3, 1:3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 1 2 3 m &lt;- matrix(1:6, byrow = TRUE, nrow = 2) m #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 rbind(m, 7:9) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 cbind(m, c(10, 11)) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 3 10 #&gt; [2,] 4 5 6 11 vector에서 사용한 names처럼, 행열에 대응하는 함수가 있습니다. rownames, colnames가 그것인데요. ?rownames와 ?colnames로 자세한 내용을 더 확인해 보시기 바랍니다. m &lt;- matrix(1:6, byrow = TRUE, nrow = 2) m #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 rownames(m) #&gt; NULL rownames(m) &lt;- c(&quot;row1&quot;, &quot;row2&quot;) m #&gt; [,1] [,2] [,3] #&gt; row1 1 2 3 #&gt; row2 4 5 6 colnames(m) #&gt; NULL colnames(m) &lt;- c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;) m #&gt; col1 col2 col3 #&gt; row1 1 2 3 #&gt; row2 4 5 6 vector처럼 처음부터 만들 때 이름을 지정해 줄 수도 있습니다. m &lt;- matrix(1:6, byrow = TRUE, nrow = 2, dimnames = list(c(&quot;row1&quot;, &quot;row2&quot;), c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;))) m #&gt; col1 col2 col3 #&gt; row1 1 2 3 #&gt; row2 4 5 6 matrix도 vector와 같이 한 matrix내의 데이터는 모두 같은 자료형이어야 합니다. 이건 자연스럽다고 생각하는 건지 Warning도 주지 않으니 조심하셔야 합니다. num &lt;- matrix(1:8, ncol = 2) char &lt;- matrix(LETTERS[1:6], nrow = 4, ncol = 3) cbind(num, char) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] &quot;1&quot; &quot;5&quot; &quot;A&quot; &quot;E&quot; &quot;C&quot; #&gt; [2,] &quot;2&quot; &quot;6&quot; &quot;B&quot; &quot;F&quot; &quot;D&quot; #&gt; [3,] &quot;3&quot; &quot;7&quot; &quot;C&quot; &quot;A&quot; &quot;E&quot; #&gt; [4,] &quot;4&quot; &quot;8&quot; &quot;D&quot; &quot;B&quot; &quot;F&quot; 2.3.2 matrix에서 일부 데이터 불러오기 matrix에서 일부 데이터를 불러오는 방법은 vector와 완전히 같습니다. vector에서 [ ]를 설명하면서 차원에 대해 이야기 했었는데요. matrix는 2차원이기 때문에 중간에 쉼표가 들어가야 합니다. m &lt;- matrix(sample(1:15, 12), nrow = 3) m #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 15 10 9 #&gt; [2,] 12 1 3 7 #&gt; [3,] 8 5 6 11 m[1,3] #&gt; [1] 10 m[3,2] #&gt; [1] 5 쉼표만 사용하고 어느 하나의 차원을 지정하지 않으면, 모두 불러온 것으로 가정합니다. m[3,] #&gt; [1] 8 5 6 11 m[,3] #&gt; [1] 10 3 6 신기하게도, 1차원인 vector의 일부 데이터 불러로기의 문법도 사용할 수 있습니다. m9가 어느 위치의 값인지 잘 찾아보시기 바랍니다. m[4] #&gt; [1] 15 m[9] #&gt; [1] 6 여전히 vector와 같이 어느 한 차원 내에서 여러개를 사용하기 위해서는 c와 함께 사용합니다. m[2, c(2, 3)] #&gt; [1] 1 3 m[c(1, 2), c(2, 3)] #&gt; [,1] [,2] #&gt; [1,] 15 10 #&gt; [2,] 1 3 m[c(1, 3), c(1, 3, 4)] #&gt; [,1] [,2] [,3] #&gt; [1,] 2 10 9 #&gt; [2,] 8 6 11 역시 이름을 사용해서 일부 데이터만 불러오는 것도 가능합니다. rownames(m) &lt;- c(&quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;) colnames(m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) m #&gt; a b c d #&gt; r1 2 15 10 9 #&gt; r2 12 1 3 7 #&gt; r3 8 5 6 11 m[2,3] #&gt; [1] 3 m[&quot;r2&quot;,&quot;c&quot;] #&gt; [1] 3 m[2,&quot;c&quot;] #&gt; [1] 3 m[3, c(&quot;c&quot;, &quot;d&quot;)] #&gt; c d #&gt; 6 11 2.4 팩터 2.4.1 명목형 변수 R에 대해서 이야기 하면서 통계에 대한 이야기가 나오지 않을 수가 없는데요. factor는 categorical data를 표현하기 위해 만들어진 자료형이기 때문입니다. 통계에서 사용하는 자료형은 여기를 참고하세요. 가장 대표적인 categorical data인 혈액형을 예시로 factor를 사용해 보겠습니다. blood &lt;- c(&quot;B&quot;, &quot;AB&quot;, &quot;O&quot;, &quot;A&quot;, &quot;O&quot;, &quot;O&quot;, &quot;A&quot;, &quot;B&quot;) blood #&gt; [1] &quot;B&quot; &quot;AB&quot; &quot;O&quot; &quot;A&quot; &quot;O&quot; &quot;O&quot; &quot;A&quot; &quot;B&quot; str(blood) #&gt; chr [1:8] &quot;B&quot; &quot;AB&quot; &quot;O&quot; &quot;A&quot; &quot;O&quot; &quot;O&quot; &quot;A&quot; &quot;B&quot; blood_factor &lt;- factor(blood) blood_factor #&gt; [1] B AB O A O O A B #&gt; Levels: A AB B O str(blood_factor) #&gt; Factor w/ 4 levels &quot;A&quot;,&quot;AB&quot;,&quot;B&quot;,&quot;O&quot;: 3 2 4 1 4 4 1 3 자료의 상태를 파악하는 함수로 str를 사용했습니다. str은 변수의 구조가 어떻게 구성되어 있는지를 보여주는 함수로, 데이터를 파악하는데 좋은 방법입니다. 비슷한 다른 방법들로, summary, head 등이 있습니다. ?str, ?summary, ?head를 입력해서 내용을 확인해 보세요. chr [1:8] &quot;B&quot; &quot;AB&quot; &quot;O&quot; &quot;A&quot; &quot;O&quot; &quot;O&quot; &quot;A&quot; &quot;B&quot; 에서 chr는 character의 줄임 표현입니다. 그 다름 [1:8]은 데이터가 8개 있다는 뜻입니다. 그 이후에는 8개의 데이터가 모두 출력되었습니다. facter는 character와 다르게 Levels: A AB B O라는 줄이 추가 되었습니다. 그리고 데이터를 표현할 때 &quot;가 없어졌네요. 우선 그것만으로도 character가 아님을 판단할 수 있습니다. str(blood_factor)의 결과도 보겠습니다. Factor w/ 4 levels &quot;A&quot;,&quot;AB&quot;,&quot;B&quot;,&quot;O&quot;: 3 2 4 1 4 4 1 3에서 독특한 부분이 있습니다. 데이터가 숫자로 되어 있네요. 데이터와 비교해 보면 levels &quot;A&quot;, &quot;AB&quot;, &quot;B&quot;, &quot;0&quot;에서 3번째는 &quot;B&quot;입니다. 첫번째 데이터가 &quot;B&quot;인걸 보니 숫자는 levels에서 몇 번째 데이터인지를 뜻하는 것 같습니다. 다른 숫자들도 확인해 보세요. vector처럼 변수에 선언할 때 처음부터 levels를 지정할 수 도 있습니다. 순서를 지정하는 것도 가능합니다. 처음에 만든 blood_factor와 blood_factor2가 어떻게 다른지 비교해 보세요. blood_factor2 &lt;- factor(blood, levels = c(&quot;O&quot;, &quot;A&quot;, &quot;B&quot;, &quot;AB&quot;)) blood_factor2 #&gt; [1] B AB O A O O A B #&gt; Levels: O A B AB str(blood_factor2) #&gt; Factor w/ 4 levels &quot;O&quot;,&quot;A&quot;,&quot;B&quot;,&quot;AB&quot;: 3 4 1 2 1 1 2 3 str(blood_factor) #&gt; Factor w/ 4 levels &quot;A&quot;,&quot;AB&quot;,&quot;B&quot;,&quot;O&quot;: 3 2 4 1 4 4 1 3 names처럼 levels도 중간에 바꿀 수 있습니다. labels라는 것도 있는데, 이것은 데이터의 값을 뜻합니다. 어떻게 달라지는지 확인해 보세요. blood &lt;- c(&quot;B&quot;, &quot;AB&quot;, &quot;O&quot;, &quot;A&quot;, &quot;O&quot;, &quot;O&quot;, &quot;A&quot;, &quot;B&quot;) blood_factor &lt;- factor(blood) blood_factor #&gt; [1] B AB O A O O A B #&gt; Levels: A AB B O levels(blood_factor) &lt;- c(&quot;BT_A&quot;, &quot;BT_AB&quot;, &quot;BT_B&quot;, &quot;BT_O&quot;) blood_factor #&gt; [1] BT_B BT_AB BT_O BT_A BT_O BT_O BT_A BT_B #&gt; Levels: BT_A BT_AB BT_B BT_O factor(blood, labels = c(&quot;BT_A&quot;, &quot;BT_AB&quot;, &quot;BT_B&quot;, &quot;BT_O&quot;)) #&gt; [1] BT_B BT_AB BT_O BT_A BT_O BT_O BT_A BT_B #&gt; Levels: BT_A BT_AB BT_B BT_O factor는 명목형 변수여서 크기를 비교할 수 없습니다. blood &lt;- c(&quot;B&quot;, &quot;AB&quot;, &quot;O&quot;, &quot;A&quot;, &quot;O&quot;, &quot;O&quot;, &quot;A&quot;, &quot;B&quot;) blood_factor &lt;- factor(blood) blood_factor[1] &lt; blood_factor[2] #&gt; Warning in Ops.factor(blood_factor[1], blood_factor[2]): 요인(factors)에 대 #&gt; 하여 의미있는 &#39;&lt;&#39;가 아닙니다. #&gt; [1] NA 하지만 크기를 비교할 수 있는 형태로 선언할 수 도 있습니다. tshirt &lt;- c(&quot;M&quot;, &quot;L&quot;, &quot;S&quot;, &quot;S&quot;, &quot;L&quot;, &quot;M&quot;, &quot;L&quot;, &quot;M&quot;) tshirt_factor &lt;- factor(tshirt, ordered = TRUE, levels = c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) tshirt_factor #&gt; [1] M L S S L M L M #&gt; Levels: S &lt; M &lt; L tshirt_factor[1] &lt; tshirt_factor[2] #&gt; [1] TRUE 2.5 리스트 2.5.1 다른 종류의 자료형들이 함께 지금까지 전부 같은 자료형의 데이터가 모여 있는 형태의 자료형을 알아봤습니다. 같은 자료형으로 구성하는 것은 계산의 효율등 분명한 장점도 있지만, 그것을 사용하는 사람이 이해하기 어렵거나 불편할 때가 있습니다. 특히 다양한 자료형으로 구성된 데이터일 때 하나의 변수로 관리하기 위해서는 list를 사용해 합니다. 아래 c와 list로 만든 데이터를 비교해 보겠습니다. c(&quot;Rsome times&quot;, 190, 5) #&gt; [1] &quot;Rsome times&quot; &quot;190&quot; &quot;5&quot; list(&quot;Rsome times&quot;, 190, 5) #&gt; [[1]] #&gt; [1] &quot;Rsome times&quot; #&gt; #&gt; [[2]] #&gt; [1] 190 #&gt; #&gt; [[3]] #&gt; [1] 5 song &lt;- list(&quot;Rsome times&quot;, 190, 5) is.list(song) #&gt; [1] TRUE list 역시 is.list 함수가 있네요. c로 만들어진 데이터는 자료형을 강제로 전부 character로 바꾸었습니다. list는 데이터가 주욱 늘어지고, 숫자들은 숫자 데이터로 표현된 것 같습니다. 이 때 처음 보는 것이 있는데요. [[ ]]입니다. 이것은 vector가 하나의 자료형으로만 이루어져야 하는 점에 착안하여, vector를 여러 개 합쳐 list를 만듬으로써 문제를 해결했습니다. 그렇기 때문에 일부의 데이터를 불러오는 [ ]과 비슷하지만 합쳐져 있는 그 내부의 vector를 불러오는 [[ ]] 문법이 만들어 지게 되었습니다. [ ]과 [[ ]]를 실험해 보세요. song[3] #&gt; [[1]] #&gt; [1] 5 class(song[3]) #&gt; [1] &quot;list&quot; song[[3]] #&gt; [1] 5 class(song[[3]]) #&gt; [1] &quot;numeric&quot; list도 다른 자료형들 처럼 names를 사용합니다. song &lt;- list(&quot;Rsome times&quot;, 190, 5) names(song) &lt;- c(&quot;title&quot;, &quot;duration&quot;, &quot;track&quot;) song #&gt; $title #&gt; [1] &quot;Rsome times&quot; #&gt; #&gt; $duration #&gt; [1] 190 #&gt; #&gt; $track #&gt; [1] 5 이번엔 [[ ]] 위치에 $title 같이 $ + names의 문법이 나타났습니다. 이것이 list의 이름을 짓는 방법입니다. 이름으로 데이터를 부르는 방법은 더 복잡한 모양의 데이터를 만들고 실습해보기로 하고, list가 가진 다른 특성을 확인해 보겠습니다. song &lt;- list(title = &quot;Rsome times&quot;, duration = 190, track = 5) str(song) #&gt; List of 3 #&gt; $ title : chr &quot;Rsome times&quot; #&gt; $ duration: num 190 #&gt; $ track : num 5 similar_song &lt;- list(title = &quot;R you on time?&quot;, duration = 230) song &lt;- list(title = &quot;Rsome times&quot;, duration = 190, track = 5, similar = similar_song) str(song) #&gt; List of 4 #&gt; $ title : chr &quot;Rsome times&quot; #&gt; $ duration: num 190 #&gt; $ track : num 5 #&gt; $ similar :List of 2 #&gt; ..$ title : chr &quot;R you on time?&quot; #&gt; ..$ duration: num 230 list 안에 list가 들어가 있네요 str로 확인해 보니 list 안에 list가 ..$로 들여쓰기 되어 표현되어 있습니다. 데이터 표현도 List of 2라고 str(song)의 맨 윗줄(List of 4)과 같은 모양이 보입니다. 이것처럼 list는 대부분의 자료형을 요소로 가질 수 있습니다. list는 인터넷에서 많이 사용하는 자료형인 JSON에 대응됩니다. 과거에는 XML도 사용했다고 알고 있는데, 최근에는 많은 곳에서 JSON으로 사용하고 있습니다. JSON에 대해서는 이곳의 예제를 참고하세요 library(N2H4) url&lt;-&quot;http://news.naver.com/main/read.nhn?mode=LSD&amp;mid=shm&amp;sid1=100&amp;oid=437&amp;aid=0000152054&quot; tem&lt;-getComment(url) #&gt; [1] &quot;success : TRUE&quot; str(tem) #&gt; &#39;data.frame&#39;: 1 obs. of 7 variables: #&gt; $ success: logi TRUE #&gt; $ code : chr &quot;1000&quot; #&gt; $ message: chr &quot;요청을 성공적으로 처리하였습니다.&quot; #&gt; $ lang : chr &quot;ko&quot; #&gt; $ country: chr &quot;KR&quot; #&gt; $ result :&#39;data.frame&#39;: 1 obs. of 11 variables: #&gt; ..$ listStatus : chr &quot;current&quot; #&gt; ..$ sort : chr &quot;FAVORITE&quot; #&gt; ..$ graph :&#39;data.frame&#39;: 1 obs. of 3 variables: #&gt; .. ..$ gender:&#39;data.frame&#39;: 1 obs. of 2 variables: #&gt; .. .. ..$ male : int 75 #&gt; .. .. ..$ female: int 25 #&gt; .. ..$ old :List of 1 #&gt; .. .. ..$ :&#39;data.frame&#39;: 5 obs. of 5 variables: #&gt; .. .. .. ..$ age : chr &quot;10&quot; &quot;20&quot; &quot;30&quot; &quot;40&quot; ... #&gt; .. .. .. ..$ value: int 2 18 34 24 22 #&gt; .. .. .. ..$ type : chr &quot;exact&quot; &quot;exact&quot; &quot;exact&quot; &quot;exact&quot; ... #&gt; .. .. .. ..$ min : logi TRUE FALSE FALSE FALSE FALSE #&gt; .. .. .. ..$ max : logi FALSE FALSE TRUE FALSE FALSE #&gt; .. ..$ empty : logi FALSE #&gt; ..$ count :&#39;data.frame&#39;: 1 obs. of 8 variables: #&gt; .. ..$ comment : int 1031 #&gt; .. ..$ reply : int 478 #&gt; .. ..$ exposeCount : int 1104 #&gt; .. ..$ delCommentByUser : int 0 #&gt; .. ..$ delCommentByMon : int 4 #&gt; .. ..$ blindCommentByUser: int 0 #&gt; .. ..$ blindReplyByUser : int 0 #&gt; .. ..$ total : int 1509 #&gt; ..$ config :&#39;data.frame&#39;: 1 obs. of 78 variables: #&gt; .. ..$ useSnsLogin : logi TRUE #&gt; .. ..$ lineFeedOn : logi FALSE #&gt; .. ..$ useBest : logi FALSE #&gt; .. ..$ useVote : logi TRUE #&gt; .. ..$ useVoteSelf : logi FALSE #&gt; .. ..$ useVoteGoodOnly : logi FALSE #&gt; .. ..$ useReport : logi TRUE #&gt; .. ..$ useCommonReport : logi FALSE #&gt; .. ..$ useSort : logi TRUE #&gt; .. ..$ sortTypes :List of 1 #&gt; .. .. ..$ : chr &quot;FAVORITE&quot; &quot;NEW&quot; &quot;RELATIVE&quot; #&gt; .. ..$ defaultSort : chr &quot;FAVORITE&quot; #&gt; .. ..$ useByteLength : logi FALSE #&gt; .. ..$ useReply : logi TRUE #&gt; .. ..$ useAutoRefresh : logi FALSE #&gt; .. ..$ useMention : logi FALSE #&gt; .. ..$ min : int 1 #&gt; .. ..$ max : int 300 #&gt; .. ..$ useSticker : logi FALSE #&gt; .. ..$ stickerOnly : logi FALSE #&gt; .. ..$ stickerSupportedCategories : logi NA #&gt; .. ..$ stickerDefaultCategory : logi NA #&gt; .. ..$ stickerCategory : logi NA #&gt; .. ..$ stickerContentsUrl : logi NA #&gt; .. ..$ stickerKeyUrl : logi NA #&gt; .. ..$ stickerTabUrl : logi NA #&gt; .. ..$ stickerType : logi NA #&gt; .. ..$ stickerText : logi FALSE #&gt; .. ..$ stickerMarketUrl : logi NA #&gt; .. ..$ stickerMobileResize : logi FALSE #&gt; .. ..$ useProfile : logi FALSE #&gt; .. ..$ profileEmptyImage : logi NA #&gt; .. ..$ displayMaskedUserId : logi FALSE #&gt; .. ..$ useManager : logi FALSE #&gt; .. ..$ managerDelete : logi FALSE #&gt; .. ..$ managerBlock : logi FALSE #&gt; .. ..$ managerNotice : logi FALSE #&gt; .. ..$ contentsManagerIcon : logi FALSE #&gt; .. ..$ secretComment : logi FALSE #&gt; .. ..$ exposureConfig : logi FALSE #&gt; .. ..$ deleteAllAfterBlock : logi FALSE #&gt; .. ..$ useFold : logi TRUE #&gt; .. ..$ replyPreviewCount : int 0 #&gt; .. ..$ maxImageUploadCount : int 0 #&gt; .. ..$ maxImageUploadFileSize : int 0 #&gt; .. ..$ imageAutoRotate : logi FALSE #&gt; .. ..$ autoRefreshTime : int 0 #&gt; .. ..$ autoRefreshDefaultOff : logi FALSE #&gt; .. ..$ autoRefreshChat : logi FALSE #&gt; .. ..$ maxChatFPS : int 0 #&gt; .. ..$ commentModify : logi FALSE #&gt; .. ..$ useCommentModify : logi FALSE #&gt; .. ..$ useViewAll : logi TRUE #&gt; .. ..$ useSnsComment : logi TRUE #&gt; .. ..$ snsCommentDefaultOn : logi TRUE #&gt; .. ..$ useUserLevel : logi FALSE #&gt; .. ..$ useUserBlind : logi FALSE #&gt; .. ..$ maxUserBlindCount : int 0 #&gt; .. ..$ useImageComment : logi FALSE #&gt; .. ..$ useUrlLink : logi FALSE #&gt; .. ..$ useCommentListIncludeDelete: logi FALSE #&gt; .. ..$ useStats : logi TRUE #&gt; .. ..$ useGpopCache : logi FALSE #&gt; .. ..$ useEnterSubmit : logi FALSE #&gt; .. ..$ useListReverse : logi FALSE #&gt; .. ..$ useTranslation : logi FALSE #&gt; .. ..$ useDeletedList : logi TRUE #&gt; .. ..$ useAudio : logi FALSE #&gt; .. ..$ combinedDeletedList : logi TRUE #&gt; .. ..$ displayDeletedList : logi FALSE #&gt; .. ..$ photoInfraUploadDomain : logi NA #&gt; .. ..$ photoInfraSelectDomainHttp : logi NA #&gt; .. ..$ photoInfraSelectDomainHttps: logi NA #&gt; .. ..$ pcTempThumbnailType : chr &quot;ff80_80&quot; #&gt; .. ..$ mobileTempThumbnailType : chr &quot;ff50_50&quot; #&gt; .. ..$ realnameVerificationBlock : logi FALSE #&gt; .. ..$ realnameVerificationMessage: logi NA #&gt; .. ..$ useBlindByReport : logi TRUE #&gt; .. ..$ hashtagMaxLength : int 20 #&gt; ..$ exposureConfig:&#39;data.frame&#39;: 1 obs. of 2 variables: #&gt; .. ..$ reason: logi NA #&gt; .. ..$ status: chr &quot;COMMENT_ON&quot; #&gt; ..$ bestList :List of 1 #&gt; .. ..$ : list() #&gt; ..$ notice :&#39;data.frame&#39;: 1 obs. of 4 variables: #&gt; .. ..$ noticeNo: int 12 #&gt; .. ..$ title : chr &quot;6/22 밤10시부터 댓글접기/이력공개 오픈&quot; #&gt; .. ..$ content : chr &quot;안녕하세요, 네이버 뉴스입니다.\\r&lt;br&gt;\\r&lt;br&gt;하루에도 수 많은 의견들이 교환되는 뉴스 댓글 공간을 더 투명하게 서비&quot;| __truncated__ #&gt; .. ..$ regTime : chr &quot;2017-06-22T22:51:57+0900&quot; #&gt; ..$ userInfo :&#39;data.frame&#39;: 1 obs. of 0 variables #&gt; ..$ pageModel :&#39;data.frame&#39;: 1 obs. of 16 variables: #&gt; .. ..$ page : int 1 #&gt; .. ..$ pageSize : int 10 #&gt; .. ..$ indexSize : int 10 #&gt; .. ..$ startRow : int 1 #&gt; .. ..$ endRow : int 10 #&gt; .. ..$ totalRows : int 1031 #&gt; .. ..$ startIndex : int 0 #&gt; .. ..$ totalPages : int 104 #&gt; .. ..$ firstPage : int 1 #&gt; .. ..$ prevPage : int 0 #&gt; .. ..$ nextPage : int 2 #&gt; .. ..$ lastPage : int 10 #&gt; .. ..$ current : logi NA #&gt; .. ..$ moveToLastPage: logi FALSE #&gt; .. ..$ moveToComment : logi FALSE #&gt; .. ..$ moveToLastPrev: logi FALSE #&gt; ..$ commentList :List of 1 #&gt; .. ..$ :&#39;data.frame&#39;: 10 obs. of 69 variables: #&gt; .. .. ..$ ticket : chr &quot;news&quot; &quot;news&quot; &quot;news&quot; &quot;news&quot; ... #&gt; .. .. ..$ objectId : chr &quot;news437,0000152054&quot; &quot;news437,0000152054&quot; &quot;news437,0000152054&quot; &quot;news437,0000152054&quot; ... #&gt; .. .. ..$ categoryId : chr &quot;*&quot; &quot;*&quot; &quot;*&quot; &quot;*&quot; ... #&gt; .. .. ..$ templateId : chr &quot;default&quot; &quot;view&quot; &quot;view_politics&quot; &quot;default&quot; ... #&gt; .. .. ..$ commentNo : int 895990872 895990402 895993542 895994142 895997652 895994952 895998652 895990312 895993642 896006322 #&gt; .. .. ..$ parentCommentNo : int 895990872 895990402 895993542 895994142 895997652 895994952 895998652 895990312 895993642 896006322 #&gt; .. .. ..$ replyLevel : int 1 1 1 1 1 1 1 1 1 1 #&gt; .. .. ..$ replyCount : int 46 28 25 6 0 1 3 4 0 0 #&gt; .. .. ..$ replyAllCount : int 0 0 0 0 0 0 0 0 0 0 #&gt; .. .. ..$ replyPreviewNo : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ replyList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ imageCount : int 0 0 0 0 0 0 0 0 0 0 #&gt; .. .. ..$ imageList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ imagePathList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ imageWidthList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ imageHeightList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ commentType : chr &quot;txt&quot; &quot;txt&quot; &quot;txt&quot; &quot;txt&quot; ... #&gt; .. .. ..$ stickerId : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ sticker : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ sortValue : num 1.49e+12 1.49e+12 1.49e+12 1.49e+12 1.49e+12 ... #&gt; .. .. ..$ contents : chr &quot;국회의원에게 권력을 나눠주느니 차라리 대통령중심제 해라. 각당 원내대표들이 돌아가며 총리 해먹는 꼴 못본다&quot; &quot;4년 중임제가 답이다&quot; &quot;의원내각제는 진짜로 박지원 상왕 만들자는 개헌이지&quot; &quot;박지원이 그렇게 개헌 개헌 하더니만...안후보 대통령만들고 나면 총리자리 달라고 하겠네 ㅎㅎ&quot; ... #&gt; .. .. ..$ userIdNo : chr &quot;oCJq&quot; &quot;5qcIZ&quot; &quot;9oKyX&quot; &quot;6U92Q&quot; ... #&gt; .. .. ..$ lang : chr &quot;ko&quot; &quot;ko&quot; &quot;ko&quot; &quot;ko&quot; ... #&gt; .. .. ..$ country : chr &quot;KR&quot; &quot;KR&quot; &quot;KR&quot; &quot;KR&quot; ... #&gt; .. .. ..$ idType : chr &quot;naver&quot; &quot;naver&quot; &quot;naver&quot; &quot;naver&quot; ... #&gt; .. .. ..$ idProvider : chr &quot;naver&quot; &quot;naver&quot; &quot;naver&quot; &quot;naver&quot; ... #&gt; .. .. ..$ userName : chr &quot;ssan****&quot; &quot;zamp****&quot; &quot;tjto****&quot; &quot;hb12****&quot; ... #&gt; .. .. ..$ userProfileImage: chr &quot;http://profile.phinf.naver.net/47661/c2300c203d789c4761cb7256042c54e1434afc037bc9e510593d610b89108090.jpg&quot; &quot;http://profile.phinf.naver.net/27148/f77ca3b0a86973c627361a946e9ae3a198c8557fd608f07ead8df1f060808693.jpg&quot; &quot;http://profile.phinf.naver.net/43378/842d4ba6140c89c75e27abf1f0a48910de3c4f95bac6fe9e7347cbbf831e6f42.jpg&quot; &quot;http://profile.phinf.naver.net/46045/e902b85b86479646dd8db2c3b95857cbe4dcd058ea7fb0c36592ecdf6107350d.jpg&quot; ... #&gt; .. .. ..$ profileType : chr &quot;naver&quot; &quot;naver&quot; &quot;naver&quot; &quot;naver&quot; ... #&gt; .. .. ..$ modTime : chr &quot;2017-04-12T21:00:55+0900&quot; &quot;2017-04-12T21:00:21+0900&quot; &quot;2017-04-12T21:04:44+0900&quot; &quot;2017-04-12T21:05:26+0900&quot; ... #&gt; .. .. ..$ modTimeGmt : chr &quot;2017-04-12T12:00:55+0000&quot; &quot;2017-04-12T12:00:21+0000&quot; &quot;2017-04-12T12:04:44+0000&quot; &quot;2017-04-12T12:05:26+0000&quot; ... #&gt; .. .. ..$ regTime : chr &quot;2017-04-12T21:00:55+0900&quot; &quot;2017-04-12T21:00:21+0900&quot; &quot;2017-04-12T21:04:44+0900&quot; &quot;2017-04-12T21:05:26+0900&quot; ... #&gt; .. .. ..$ regTimeGmt : chr &quot;2017-04-12T12:00:55+0000&quot; &quot;2017-04-12T12:00:21+0000&quot; &quot;2017-04-12T12:04:44+0000&quot; &quot;2017-04-12T12:05:26+0000&quot; ... #&gt; .. .. ..$ sympathyCount : int 2360 1907 1914 645 470 428 446 404 262 237 #&gt; .. .. ..$ antipathyCount : int 70 100 152 37 5 10 39 34 4 5 #&gt; .. .. ..$ userBlind : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ hideReplyButton : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ status : int 0 0 0 0 0 0 0 0 0 0 #&gt; .. .. ..$ mine : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ best : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ mentions : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ userStatus : int 0 0 0 0 0 0 0 0 0 0 #&gt; .. .. ..$ categoryImage : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ open : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ levelCode : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ grades : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ sympathy : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ antipathy : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ snsList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ metaInfo : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ extension : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ audioInfoList : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ translation : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ report : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ visible : logi TRUE TRUE TRUE TRUE TRUE TRUE ... #&gt; .. .. ..$ virtual : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ exposeByCountry : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ validateBanWords: logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ manager : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ deleted : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ blindReport : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ shardTableNo : int 144 144 144 144 144 144 144 144 144 144 #&gt; .. .. ..$ secret : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ blind : logi FALSE FALSE FALSE FALSE FALSE FALSE ... #&gt; .. .. ..$ expose : logi TRUE TRUE TRUE TRUE TRUE TRUE ... #&gt; .. .. ..$ profileUserId : logi NA NA NA NA NA NA ... #&gt; .. .. ..$ containText : logi TRUE TRUE TRUE TRUE TRUE TRUE ... #&gt; .. .. ..$ maskedUserId : chr &quot;ssan****&quot; &quot;zamp****&quot; &quot;tjto****&quot; &quot;hb12****&quot; ... #&gt; .. .. ..$ maskedUserName : chr &quot;ss****&quot; &quot;za****&quot; &quot;tj****&quot; &quot;hb****&quot; ... #&gt; $ date : chr &quot;2017-08-20T07:31:00+0000&quot; JSON을 전문적으로 다루기 위한 패키지도 있으니 확인해 보세요. 2.5.2 리스트의 일부 데이터 불러오기 이제 list에서 일부 데이터를 불러오는 실습을 해보겠습니다. 다른 자료형처럼 데이터의 일부를 불러오는 방법과 이름을 사용하는 방법, [[ ]]를 사용하고, $ + 데이터의 이름을 사용하는 방법들이 있습니다. similar_song &lt;- list(title = &quot;R you on time?&quot;, duration = 230) song &lt;- list(title = &quot;Rsome times&quot;, duration = 190, track = 5, similar = similar_song) song #&gt; $title #&gt; [1] &quot;Rsome times&quot; #&gt; #&gt; $duration #&gt; [1] 190 #&gt; #&gt; $track #&gt; [1] 5 #&gt; #&gt; $similar #&gt; $similar$title #&gt; [1] &quot;R you on time?&quot; #&gt; #&gt; $similar$duration #&gt; [1] 230 song[1] #&gt; $title #&gt; [1] &quot;Rsome times&quot; song[[1]] #&gt; [1] &quot;Rsome times&quot; song[c(1, 3)] #&gt; $title #&gt; [1] &quot;Rsome times&quot; #&gt; #&gt; $track #&gt; [1] 5 &gt; song[[c(1, 3)]] ## Error in song[[c(1, 3)]] : subscript out of bounds &gt; song[[1]][[3]] ## Error in song[[1]][[3]] : subscript out of bounds devtools::install_github(“forkonlp/N2H4”) song[[3]][[1]] #&gt; [1] 5 song[[c(4, 1)]] #&gt; [1] &quot;R you on time?&quot; song[[&quot;duration&quot;]] #&gt; [1] 190 song[&quot;duration&quot;] #&gt; $duration #&gt; [1] 190 song[c(&quot;duration&quot;, &quot;similar&quot;)] #&gt; $duration #&gt; [1] 190 #&gt; #&gt; $similar #&gt; $similar$title #&gt; [1] &quot;R you on time?&quot; #&gt; #&gt; $similar$duration #&gt; [1] 230 song$duration #&gt; [1] 190 friends &lt;- c(&quot;Kurt&quot;, &quot;Florence&quot;, &quot;Patti&quot;, &quot;Dave&quot;) song$sent &lt;- friends song #&gt; $title #&gt; [1] &quot;Rsome times&quot; #&gt; #&gt; $duration #&gt; [1] 190 #&gt; #&gt; $track #&gt; [1] 5 #&gt; #&gt; $similar #&gt; $similar$title #&gt; [1] &quot;R you on time?&quot; #&gt; #&gt; $similar$duration #&gt; [1] 230 #&gt; #&gt; #&gt; $sent #&gt; [1] &quot;Kurt&quot; &quot;Florence&quot; &quot;Patti&quot; &quot;Dave&quot; song[[&quot;sent&quot;]] &lt;- friends song$similar$reason &lt;- &quot;too long&quot; song #&gt; $title #&gt; [1] &quot;Rsome times&quot; #&gt; #&gt; $duration #&gt; [1] 190 #&gt; #&gt; $track #&gt; [1] 5 #&gt; #&gt; $similar #&gt; $similar$title #&gt; [1] &quot;R you on time?&quot; #&gt; #&gt; $similar$duration #&gt; [1] 230 #&gt; #&gt; $similar$reason #&gt; [1] &quot;too long&quot; #&gt; #&gt; #&gt; $sent #&gt; [1] &quot;Kurt&quot; &quot;Florence&quot; &quot;Patti&quot; &quot;Dave&quot; 2.6 데이터프레임 2.6.1 사람이 이해하기 쉬운 자료형 다양한 형태의 자료형을 묶어서 사용하는 list를 만들고 보니, 반대로 너무 자유도가 높아서 사용하기 어려운 문제들이 나타났습니다. 그렇다 보니 조금 제약사항을 만들어 보기로 합니다. 그렇게 해서 탄생한게 data.frame입니다. 기존에 알고 계시는 엑셀 시트나 설문조사를 정리한 표 같은 걸 생각하시면 도움이 되실 겁니다. data.frame은 list와 달리 vector를 각 열로 유지하여 합치는 방식을 사용했습니다. 그래서 하나의 열 내에서는 데이터가 vector와 같이 자료형이 모두 같아야 하고, 하나의 행에서는 자료형이 여러 개가 가능합니다. name &lt;- c(&quot;Anne&quot;, &quot;Pete&quot;, &quot;Frank&quot;, &quot;Julia&quot;, &quot;Cath&quot;) age &lt;- c(28, 30, 21, 39, 35) child &lt;- c(FALSE, TRUE, TRUE, FALSE, TRUE) df &lt;- data.frame(name, age, child) df #&gt; name age child #&gt; 1 Anne 28 FALSE #&gt; 2 Pete 30 TRUE #&gt; 3 Frank 21 TRUE #&gt; 4 Julia 39 FALSE #&gt; 5 Cath 35 TRUE 물론 names도 사용합니다. names는 열의 이름을 뜻합니다. 똑같이 처음부터 지정해 줄수 있구요. 지정하지 않으면 임의로 data.frame이 선정해서 가지고 있습니다. names(df) #&gt; [1] &quot;name&quot; &quot;age&quot; &quot;child&quot; names(df) &lt;- c(&quot;Name&quot;, &quot;Age&quot;, &quot;Child&quot;) df #&gt; Name Age Child #&gt; 1 Anne 28 FALSE #&gt; 2 Pete 30 TRUE #&gt; 3 Frank 21 TRUE #&gt; 4 Julia 39 FALSE #&gt; 5 Cath 35 TRUE df &lt;- data.frame(Name = name, Age = age, Child = child) df #&gt; Name Age Child #&gt; 1 Anne 28 FALSE #&gt; 2 Pete 30 TRUE #&gt; 3 Frank 21 TRUE #&gt; 4 Julia 39 FALSE #&gt; 5 Cath 35 TRUE str(df) #&gt; &#39;data.frame&#39;: 5 obs. of 3 variables: #&gt; $ Name : chr &quot;Anne&quot; &quot;Pete&quot; &quot;Frank&quot; &quot;Julia&quot; ... #&gt; $ Age : num 28 30 21 39 35 #&gt; $ Child: logi FALSE TRUE TRUE FALSE TRUE data.frame은 각 열의 데이터 갯수가 맞지 않으면 만들어 지지 않습니다. &gt; data.frame(name[-1], age, child) ## Error in data.frame(name[-1], age, child) : ## arguments imply differing number of rows: 4, 5 그리고 글자를 모두 factor를 기본 값으로 지정합니다. 그래서 stringsAsFactors 옵션을 FALSE로 해줘야 charater로 데이터를 만들 수 있습니다. stringsAsFactors는 options에서도 지정해서 사용할 수 있습니다. df &lt;- data.frame(name, age, child, stringsAsFactors = FALSE) str(df) #&gt; &#39;data.frame&#39;: 5 obs. of 3 variables: #&gt; $ name : chr &quot;Anne&quot; &quot;Pete&quot; &quot;Frank&quot; &quot;Julia&quot; ... #&gt; $ age : num 28 30 21 39 35 #&gt; $ child: logi FALSE TRUE TRUE FALSE TRUE list와 같이 위치값이나 이름으로 데이터의 일부를 불러올 수 있습니다. name &lt;- c(&quot;Anne&quot;, &quot;Pete&quot;, &quot;Frank&quot;, &quot;Julia&quot;, &quot;Cath&quot;) age &lt;- c(28, 30, 21, 39, 35) child &lt;- c(FALSE, TRUE, TRUE, FALSE, TRUE) people &lt;- data.frame(name, age, child, stringsAsFactors = FALSE) people #&gt; name age child #&gt; 1 Anne 28 FALSE #&gt; 2 Pete 30 TRUE #&gt; 3 Frank 21 TRUE #&gt; 4 Julia 39 FALSE #&gt; 5 Cath 35 TRUE people[3,2] #&gt; [1] 21 people[3,&quot;age&quot;] #&gt; [1] 21 people[3,] #&gt; name age child #&gt; 3 Frank 21 TRUE people[,&quot;age&quot;] #&gt; [1] 28 30 21 39 35 people[c(3, 5), c(&quot;age&quot;, &quot;child&quot;)] #&gt; age child #&gt; 3 21 TRUE #&gt; 5 35 TRUE people[2] #&gt; age #&gt; 1 28 #&gt; 2 30 #&gt; 3 21 #&gt; 4 39 #&gt; 5 35 people$age #&gt; [1] 28 30 21 39 35 people[[&quot;age&quot;]] #&gt; [1] 28 30 21 39 35 people[[2]] #&gt; [1] 28 30 21 39 35 people[&quot;age&quot;] #&gt; age #&gt; 1 28 #&gt; 2 30 #&gt; 3 21 #&gt; 4 39 #&gt; 5 35 people[2] #&gt; age #&gt; 1 28 #&gt; 2 30 #&gt; 3 21 #&gt; 4 39 #&gt; 5 35 data.frame은 데이터를 추가하는 여러 가지 방법을 지원합니다. 이전에 한번씩 본 방식이니 테스트해보세요. height &lt;- c(163, 177, 163, 162, 157) people$height &lt;- height people[[&quot;height&quot;]] &lt;- height people #&gt; name age child height #&gt; 1 Anne 28 FALSE 163 #&gt; 2 Pete 30 TRUE 177 #&gt; 3 Frank 21 TRUE 163 #&gt; 4 Julia 39 FALSE 162 #&gt; 5 Cath 35 TRUE 157 weight &lt;- c(74, 63, 68, 55, 56) cbind(people, weight) #&gt; name age child height weight #&gt; 1 Anne 28 FALSE 163 74 #&gt; 2 Pete 30 TRUE 177 63 #&gt; 3 Frank 21 TRUE 163 68 #&gt; 4 Julia 39 FALSE 162 55 #&gt; 5 Cath 35 TRUE 157 56 &gt; tom &lt;- data.frame(&quot;Tom&quot;, 37, FALSE, 183) &gt; rbind(people, tom) ## Error in match.names(clabs, names(xi)) : ## names do not match previous names tom &lt;- data.frame(name = &quot;Tom&quot;, age = 37, child = FALSE, height = 183) rbind(people, tom) #&gt; name age child height #&gt; 1 Anne 28 FALSE 163 #&gt; 2 Pete 30 TRUE 177 #&gt; 3 Frank 21 TRUE 163 #&gt; 4 Julia 39 FALSE 162 #&gt; 5 Cath 35 TRUE 157 #&gt; 6 Tom 37 FALSE 183 2.6.2 순서에 대해 작업하기 순서는 data.frame뿐만 아니라 다른 자료형에서도 그대로 적용되는 내용입니다. 여기서는 sort와 order에 대해서 알아보겠습니다. sort(people$age) #&gt; [1] 21 28 30 35 39 ranks &lt;- order(people$age) ranks #&gt; [1] 3 1 2 5 4 people$age #&gt; [1] 28 30 21 39 35 ranks &lt;- order(people$age) ranks #&gt; [1] 3 1 2 5 4 people[ranks, ] #&gt; name age child height #&gt; 3 Frank 21 TRUE 163 #&gt; 1 Anne 28 FALSE 163 #&gt; 2 Pete 30 TRUE 177 #&gt; 5 Cath 35 TRUE 157 #&gt; 4 Julia 39 FALSE 162 people[order(people$age, decreasing = TRUE), ] #&gt; name age child height #&gt; 4 Julia 39 FALSE 162 #&gt; 5 Cath 35 TRUE 157 #&gt; 2 Pete 30 TRUE 177 #&gt; 1 Anne 28 FALSE 163 #&gt; 3 Frank 21 TRUE 163 sort는 순서가 있는 데이터(지금의 예시로는 나이)를 오름차순으로 정렬해줍니다. 글자라면 알파벳순으로 정렬해 줄 것입니다. 한 번 실험해 보세요. order는 그 위치에 있는 데이터가 전체 데이터 내에서 몇 번째에 위치하는지를 알려줍니다. sort가 정렬이 끝난 결과를 보여주는 것이라면 order는 그 데이터의 순서값 자체를 보여주는 것이죠. 그렇기 때문에 order는 [ ]의 행부분 조건과 결합하여 많이 사용됩니다. 2.7 날짜 날짜는 어느 곳에서든 다루기 어려운 데이터입니다. 불규칙적인 윤달이라던지 하는 여러 가지 문제로 실제로 사용할 때 많은 문제가 있는데요, R에서는 여러 형태의 날짜를 표현하는 데이터를 Date라는 자료형으로 관리하고 있습니다. 사람들이 관행적으로 사용하는 형태의 character 날짜를 Date형으로 바꿔보겠습니다. dates &lt;- c(&quot;2016/01/01&quot;,&quot;2016/02/01&quot;,&quot;2016/03/01&quot;,&quot;2016/04/01&quot;,&quot;2016/05/01&quot;,&quot;2016/06/01&quot;) dates #&gt; [1] &quot;2016/01/01&quot; &quot;2016/02/01&quot; &quot;2016/03/01&quot; &quot;2016/04/01&quot; &quot;2016/05/01&quot; #&gt; [6] &quot;2016/06/01&quot; class(dates) #&gt; [1] &quot;character&quot; trans.dates &lt;- as.Date(dates) trans.dates #&gt; [1] &quot;2016-01-01&quot; &quot;2016-02-01&quot; &quot;2016-03-01&quot; &quot;2016-04-01&quot; &quot;2016-05-01&quot; #&gt; [6] &quot;2016-06-01&quot; class(trans.dates) #&gt; [1] &quot;Date&quot; Date형 일때의 장점은 계산이 가능하다는 것입니다. trans.dates[3]-trans.dates[1] #&gt; Time difference of 60 days 다른 모양의 character도 되는지 한번 보겠습니다. dates2 &lt;- c(&quot;2016-01-01&quot;,&quot;2016-02-01&quot;,&quot;2016-03-01&quot;,&quot;2016-04-01&quot;,&quot;2016-05-01&quot;,&quot;2016-06-01&quot;) trans.dates2 &lt;- as.Date(dates2) trans.dates2 #&gt; [1] &quot;2016-01-01&quot; &quot;2016-02-01&quot; &quot;2016-03-01&quot; &quot;2016-04-01&quot; &quot;2016-05-01&quot; #&gt; [6] &quot;2016-06-01&quot; class(trans.dates2) #&gt; [1] &quot;Date&quot; 어려운 모양은 인식하지 못합니다. 그래서 일부러 양식을 알려주면 R이 고칠 수 있는데요. &gt; as.Date(&quot;2016년 4월 5일&quot;) ## Error in charToDate(x) : 문자열이 표준서식을 따르지 않습니다 as.Date(&quot;2016년 4월 5일&quot;, format=&quot;%Y년 %m월 %d일&quot;) #&gt; [1] &quot;2016-04-05&quot; 양식은 저도 다 외우지 못하고 매번 검색해서 사용합니다. http://www.stat.berkeley.edu/classes/s133/dates.html 하지만 year의 y(4자 Y, 2자 y), month의 m, day의 d 로 생각하시면 우선 해결되고 나머지는 위에 링크를 참고해 보시면 좋을 것 같습니다. as.Date(34519, origin=&quot;1900-01-01&quot;) #&gt; [1] &quot;1994-07-06&quot; 시간은 POSIXct와 POSIXlt 두 가지로 준비되어 있습니다. 분석에 적용하는데 있어 특별히 구분해서 사용하지 않아서, 하나를 선택하셨다면 일관되게 한 가지만 계속 사용하시면 좋을 것 같습니다. # 시간 자료형 as.POSIXct(&quot;2017-04-12 12:00:00&quot;) #&gt; [1] &quot;2017-04-12 12:00:00 KST&quot; as.POSIXlt(&quot;2017-04-12 12:00:00&quot;) #&gt; [1] &quot;2017-04-12 12:00:00 KST&quot; 날짜와 시간을 다루는 패키지로 유명한 lubridate가 있습니다. 아래 여러 코드의 실행결과를 보시면 그 유연한 기능에 감탄하시게 될 겁니다. library(lubridate) #&gt; Warning: 패키지 &#39;lubridate&#39;는 R 버전 3.4.1에서 작성되었습니다 #&gt; 필요한 패키지를 로딩중입니다: methods #&gt; #&gt; 다음의 패키지를 부착합니다: &#39;lubridate&#39; #&gt; The following object is masked from &#39;package:base&#39;: #&gt; #&gt; date ymd(&quot;2017-05-05&quot;) #&gt; [1] &quot;2017-05-05&quot; ymd(&quot;170505&quot;) #&gt; [1] &quot;2017-05-05&quot; ymd(&quot;20170505&quot;) #&gt; [1] &quot;2017-05-05&quot; dmy(&quot;17-05-15&quot;) #&gt; [1] &quot;2015-05-17&quot; ymd(&quot;2017년 5월 5일&quot;) #&gt; [1] &quot;2017-05-05&quot; dmy(&quot;5일5월2017년&quot;) #&gt; [1] &quot;2017-05-05&quot; dates &lt;- c(&quot;2017-05-05&quot;,&quot;170505&quot;,&quot;20170505&quot;,&quot;17-05-15&quot;,&quot;2017년 5월 5일&quot;) ymd(dates) #&gt; [1] &quot;2017-05-05&quot; &quot;2017-05-05&quot; &quot;2017-05-05&quot; &quot;2017-05-15&quot; &quot;2017-05-05&quot; data &lt;- ymd(&quot;2017-05-05&quot;) data #&gt; [1] &quot;2017-05-05&quot; year(data) #&gt; [1] 2017 month(data) #&gt; [1] 5 month(data, label=T) #&gt; [1] May #&gt; 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec week(data) #&gt; [1] 18 yday(data) #&gt; [1] 125 mday(data) #&gt; [1] 5 wday(data) #&gt; [1] 6 wday(data, label=T) #&gt; [1] Fri #&gt; Levels: Sun &lt; Mon &lt; Tues &lt; Wed &lt; Thurs &lt; Fri &lt; Sat "],
["for-apply.html", "3 단순 반복 업무를 위한 for문과 apply류 맛보기 3.1 조건문 3.2 반복문 3.3 apply류의 함수들", " 3 단순 반복 업무를 위한 for문과 apply류 맛보기 3.1 조건문 3.1.1 if if는 if (조건) {조건이 true 이면 실행할 부분}으로 구성됩니다. if(TRUE){print(1)} #&gt; [1] 1 print(2) #&gt; [1] 2 조건은 결과가 하나의 logical 값으로 나와야 하고 여러 개의 logical 값이면 맨 앞의 값만 사용한다는 warning을 같이 출력합니다. if(c(T,F,F,F)){print(1)} #&gt; Warning in if (c(T, F, F, F)) {: length &gt; 1 이라는 조건이 있고, 첫번째 요소 #&gt; 만이 사용될 것입니다 #&gt; [1] 1 print(2) #&gt; [1] 2 보통은 아래와 같은 형식으로 사용합니다. x&lt;-1 if ( x &gt; 0 ){ print(1) } 이제까지 조건이라고 말하는 것이 있었는데, 조건이란 TRUE, FALSE로 결과가 나오는 표현 전부를 뜻합니다. 제가 if문에서 나올 만한 예시를 준비했습니다. x&lt;-c() if(identical(x,c())){print(&quot;x has no data.&quot;)} #&gt; [1] &quot;x has no data.&quot; print(&quot;if part done.&quot;) #&gt; [1] &quot;if part done.&quot; options(stringsAsFactors = F) y&lt;-c(1,2,3) z&lt;-c(1,2,3) if(length(y)==length(z)){ tem&lt;-data.frame(y,z) print(tem) } #&gt; y z #&gt; 1 1 1 #&gt; 2 2 2 #&gt; 3 3 3 print(&quot;if part done.&quot;) #&gt; [1] &quot;if part done.&quot; identical은 두 개의 변수를 비교해주고 같으면 TRUE, 다르면 FALSE를 결과로 주는 함수입니다. 결과를 logical로 주는 덕분에 조건문에 사용하기 딱 좋은 함수 입니다. 예를 들어 데이터에 무언가 문제가 생겨서 함수에 들어가지 못하거나 할때 우회하는 조건을 작성하는데 좋습니다. 저같은 경우는 N2H4 패키지를 작성할 때 getContent에서 사용했습니다. 물론 이상적으로는 정규식과 네이버 뉴스의 root url을 바탕으로 비교하는 식으로 해야 더 정교하겠습니다만, getUrlListByCategory 함수에서 생성되는 link를 사용하는 형태도 구성되어 있어서 아래와 같이 작성하였습니다. ... if(!identical(url,character(0))){ if (RCurl::url.exists(url)&amp; &quot;error_msg 404&quot;!=(read_html(url)%&gt;%html_nodes(&quot;div#main_content div div&quot;)%&gt;%html_attr(&quot;class&quot;))[1] ) { ... 3.1.2 else 영어 표현을 보면 생각하기 쉬우시겠지만 if(조건){조건이 true 이면 실행할 부분} 이후에 사용해서 조건이 false면 실행할 부분을 작성하는데 사용합니다. if (조건) {조건이 true 이면 실행할 부분} else {조건이 false 면 실행할 부분}으로 구성됩니다. if(TRUE){ print(1) } else { print(3) } #&gt; [1] 1 print(2) #&gt; [1] 2 else는 앞에 if가 조건을 작성했기 때문에 추가적인 조건을 작성하지는 않습니다. 여러 if 조건을 사용하고 그 이후에 else를 사용할 수도 있습니다. x&lt;-1 if(x&lt;0){ print(1) } if(x&gt;10) { print(3) } else { print(2) } #&gt; [1] 2 print(4) #&gt; [1] 4 최근의 코드 작성 스타일은 누가 봐도 읽고 이해하기 쉽게 이다 보니 고려하면 좋을 것 같습니다. 특히 이 스타일은 자기 자신에게도 적용이 되어서, 나중에 봐도 기억하기 쉽게 작성하는 것이 좋습니다. 3.1.3 ifelse ifelse는 앞에 함수와는 다른 결과를 제공해서 사용하는 곳이 다릅니다. 우선 형태는 ifelse(조건, 조건이 true일때 할 것, 조건이 false일때 할 것)으로 구성됩니다. 그래서 기존의 데이터를 새로운 기준으로 조정해서 사용할 때 많이 사용합니다. library(readr) #&gt; Warning: 패키지 &#39;readr&#39;는 R 버전 3.4.1에서 작성되었습니다 sd&lt;-read_csv(&quot;./data/membership.txt&quot;) #&gt; Parsed with column specification: #&gt; cols( #&gt; 고객번호 = col_character(), #&gt; 멤버십명 = col_character(), #&gt; 가입년월 = col_integer() #&gt; ) names(sd)[1]&lt;-&quot;고객번호&quot; sd&lt;-data.frame(sd) str(sd) #&gt; &#39;data.frame&#39;: 7456 obs. of 3 variables: #&gt; $ 고객번호: chr &quot;00011&quot; &quot;00021&quot; &quot;00037&quot; &quot;00043&quot; ... #&gt; $ 멤버십명: chr &quot;하이마트&quot; &quot;하이마트&quot; &quot;하이마트&quot; &quot;하이마트&quot; ... #&gt; $ 가입년월: int 201512 201506 201306 201403 201411 201312 201506 201404 201406 201311 ... summary(sd) #&gt; 고객번호 멤버십명 가입년월 #&gt; Length:7456 Length:7456 Min. :201210 #&gt; Class :character Class :character 1st Qu.:201311 #&gt; Mode :character Mode :character Median :201407 #&gt; Mean :201412 #&gt; 3rd Qu.:201504 #&gt; Max. :201512 sd$&quot;최근고객&quot;&lt;-ifelse(sd$&quot;가입년월&quot;&gt;mean(sd$&quot;가입년월&quot;),&quot;최근&quot;,&quot;최근아님&quot;) head(sd) #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 1 00011 하이마트 201512 최근 #&gt; 2 00021 하이마트 201506 최근 #&gt; 3 00037 하이마트 201306 최근아님 #&gt; 4 00043 하이마트 201403 최근아님 #&gt; 5 00044 하이마트 201411 최근아님 #&gt; 6 00061 하이마트 201312 최근아님 관련해서 여기를 가보시면 for문에 대한 간략한 방법을 질문하시고, 댓글로 여러 답변이 달렸는데, ifelse가 가장 좋은 해결책으로 보입니다. 확인해보세요. 3.1.4 try try는 error를 우회하거나 활용하기 위해서 사용하는 함수입니다. 직접 사용할 일은 많지 않지만 함수의 실행에서 에러가 났을 때 (ex&gt; data.frame은 데이터의 길이가 다르면 변수를 만들지 못하고 에러를 출력합니다.) 에러가 난 부분만 기록하고 넘기는 형태로 코드를 작성 할 수 있습니다. 더 섬세하 기능의 tryCatch 도 있으니 ?tryCatch를 확인해주세요. noObj print(1) ## Error in try(noObj) : object &#39;noObj&#39; not found try(noObj) print(1) #&gt; [1] 1 콘솔에서 실행하면 try(noObj)에서 에러가 발생합니다. 하지만 멈추는 것이 아니라 다음 코드를 실행하는 것이 그냥 noObj를 코드에 작성한 것과 차이점입니다. try를 입력해 보시면 silect 옵션이 있는데 TRUE로 해주면 에러 출력도 하지 않습니다. err&lt;-try(noObj) err #&gt; [1] &quot;Error in try(noObj) : 객체 &#39;noObj&#39;를 찾을 수 없습니다\\n&quot; #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;try-error&quot; #&gt; attr(,&quot;condition&quot;) #&gt; &lt;simpleError in doTryCatch(return(expr), name, parentenv, handler): 객체 &#39;noObj&#39;를 찾을 수 없습니다&gt; class(err) #&gt; [1] &quot;try-error&quot; 위와 같은 식으로 try(함수)를 변수에 선언하면 class(변수)를 통해 조건문을 활용해서 에러가 발생했을 때를 직접적으로 우회할 수 있습니다. 3.2 반복문 3.2.1 repeat repeat은 가장 단순한 형태의 반복 구분입니다. 그냥 repeat만 사용할 수도 있습니다만, repeat(print(1))을 실행하면 무한히 1을 출력하고 멈추지 않습니다. 강제로 멈추는 활동을 해주어야만 멈추니 주의해 주세요. 그래서 break 문법이 준비되어 있습니다. 3.2.2 break break는 말 그대로 멈추라는 명령입니다. break는 독특하게 뒤에 ()를 붙이지 않고 활용하는 함수로 조건문이나 반복문 안에 쓰여서 조건문과 반복문을 멈추는 역할을 합니다. x&lt;-1 repeat( if(x&gt;10){ break } else { print(x) x&lt;-x+1 } ) #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 #&gt; [1] 6 #&gt; [1] 7 #&gt; [1] 8 #&gt; [1] 9 #&gt; [1] 10 3.2.3 while 사실 repeat문은 사용법이 조금 길이서 잘 사용하지 않습니다. 기능적인 대체는 while문으로 가능한데, while은 while(조건){조건이 true인 동안 할 것}으로 구성됩니다. x&lt;-1 while(x&lt;10){ print(x) x&lt;-x+1 } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 #&gt; [1] 6 #&gt; [1] 7 #&gt; [1] 8 #&gt; [1] 9 위의 코드가 아까 repeat으로 만든 식과 같은 결과를 보여줍니다. 안의 조건이 달라서 이해가 어려우실 수 있어서 repeat을 다시 작성해보겠습니다. x&lt;-1 repeat( if(x&lt;10){ print(x) x&lt;-x+1 } else { break } ) #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 #&gt; [1] 6 #&gt; [1] 7 #&gt; [1] 8 #&gt; [1] 9 자유도가 높은 repeat에 비해서 while은 괄고 안의 조건이 TRUE일 때 동안만 동작합니다. 하지만 한 방법으로만 고정되어 있어서 오히려 혼란을 막고, 코드가 읽기 좋게 작성할 수 있는 장점이 있습니다. 3.2.4 for for는 반복하는 내용을 쉽게 다루기 위해서 준비되어 있습니다. 예를 들어서 위에서 while로 작성된 것을 for로 다시 작성해 보겠습니다. for(x in 1:9){ print(x) } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 #&gt; [1] 6 #&gt; [1] 7 #&gt; [1] 8 #&gt; [1] 9 while에 비해 훨씬 간결해 졌습니다. 이해하기도 좋구요. for(반복에 사용할 변수 in 반복에 사용할 변수에 넣을 데이터를 가지는 벡터){반복 실행할 내용 - 반복에 사용할 변수를 활용함}의 형태로 사용합니다. 말로 풀어 쓰려니 오히려 어려워 보이는 것 같네요. 몇 가지 예시를 더 들어 보겠습니다. data&lt;-head(sd$&quot;고객번호&quot;) for(cNum in data){ print(sd[sd$&quot;고객번호&quot;==cNum,]) } #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 1 00011 하이마트 201512 최근 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 2 00021 하이마트 201506 최근 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 3 00037 하이마트 201306 최근아님 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 4 00043 하이마트 201403 최근아님 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 5 00044 하이마트 201411 최근아님 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 6 00061 하이마트 201312 최근아님 N2H4의 사용예시도 복잡하게 무려 5중 for문(!)으로 구성되어 있습니다. 중간에 while, try, if도 다 사용되었으니 설명해 드리겠습니다. 3.2.5 next 에러에 대해 우회하는 것에 대해서 조건문을 주는 방법을 설명드렸었습니다. next는 break와 비슷하지만 조건문이나 반복문을 멈추는 것이 아니라 다음 번으로 넘기는 역할을 합니다. 예를 들면 아래와 같습니다. data&lt;-head(sd$&quot;고객번호&quot;) for(cNum in data){ if(sd[sd$&quot;고객번호&quot;==cNum,&quot;최근고객&quot;]==&quot;최근&quot;){next} print(sd[sd$&quot;고객번호&quot;==cNum,]) } #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 3 00037 하이마트 201306 최근아님 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 4 00043 하이마트 201403 최근아님 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 5 00044 하이마트 201411 최근아님 #&gt; 고객번호 멤버십명 가입년월 최근고객 #&gt; 6 00061 하이마트 201312 최근아님 출력된 내용을 보면 sd[sd$&quot;고객번호&quot;==cNum,&quot;최근고객&quot;]==&quot;최근&quot;일 때 다음 줄에 있는 print를 하지 않고 다음(next)으로 넘어간 것을 확인할 수 있습니다. 이걸 통해서 조건에 따라 그 아래 내용을 실행하지 않고 다음번 반복으로 넘기는 것이 가능합니다. N2H4의 사용예시에는 next를 사용하지 않고 while을 사용했는데, 크롤링 특성상 요청이 일부 실패도 할 수 있기 때문에 추가적인 시도를 하기 위해서 사용했습니다. 데이터를 전부 가져오는 것이 많이 중요하지 않다면 next를 사용하는 것이 더 간편하고 빠르게 작성하는 방법이 될 것 같습니다. 지금 예시를 눈으로 보여드리기 위해 for문 안을 print로 계속 채우고 있는데, print의 위치에 수행하고자 하는 함수를 작성하시면 됩니다. X&lt;-as.data.frame(matrix(1:64, ncol=4, dimnames=list(seq(1:16), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)))) X$a[c(1,3,10)]&lt;-0 for (i in 1:nrow(X)){ if (X$a[i]==0) { X$e[i]&lt;-(-999) } else { X$e[i]&lt;-X$b[i]/X$c[i] } } X #&gt; a b c d e #&gt; 1 0 17 33 49 -999.000 #&gt; 2 2 18 34 50 0.529 #&gt; 3 0 19 35 51 -999.000 #&gt; 4 4 20 36 52 0.556 #&gt; 5 5 21 37 53 0.568 #&gt; 6 6 22 38 54 0.579 #&gt; 7 7 23 39 55 0.590 #&gt; 8 8 24 40 56 0.600 #&gt; 9 9 25 41 57 0.610 #&gt; 10 0 26 42 58 -999.000 #&gt; 11 11 27 43 59 0.628 #&gt; 12 12 28 44 60 0.636 #&gt; 13 13 29 45 61 0.644 #&gt; 14 14 30 46 62 0.652 #&gt; 15 15 31 47 63 0.660 #&gt; 16 16 32 48 64 0.667 ifelse 함수에서 소개했던 질문쪽의 for로 작성된 코드입니다. for로 작성하는 것이 사실 생각하기 쉬운 방법이라고 생각합니다. 저는 심지어 처음에는 for로 작성하라고 권장합니다. 문제를 직접 겪고, 그 문제를 해결하는 방법을 찾으려할 때 그 방법이 더 몸에 남는 것 같습니다. 아래 apply를 하기 전에 for와 ifelse가 얼마나 다른지 한 번 비교해 보겠습니다. library(ggplot2) #&gt; Warning: 패키지 &#39;ggplot2&#39;는 R 버전 3.4.1에서 작성되었습니다 library(dplyr) #&gt; Warning: 패키지 &#39;dplyr&#39;는 R 버전 3.4.1에서 작성되었습니다 #&gt; #&gt; 다음의 패키지를 부착합니다: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union library(tidyr) #&gt; Warning: 패키지 &#39;tidyr&#39;는 R 버전 3.4.1에서 작성되었습니다 times&lt;-c(100,1000,10000,30000,50000,100000) tData&lt;-c() for(tm in times){ X&lt;-as.data.frame(matrix(1:tm, ncol=4, dimnames=list(seq(1:(tm/4)), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)))) X$a[c(1,3,10)]&lt;-0 forTime&lt;-system.time( for (i in 1:nrow(X)){ if (X$a[i]==0) { X$e[i]&lt;-(-999) } else { X$e[i]&lt;-X$b[i]/X$c[i] } } ) ifelseTime&lt;-system.time(X$e &lt;- ifelse(X$a == 0, -999, X$b/X$c)) forTime&lt;-cbind(data.frame(tm,cate=&quot;forTime&quot;),t(as.matrix(forTime))) ifelseTime&lt;-cbind(data.frame(tm,cate=&quot;ifelseTime&quot;),t(as.matrix(ifelseTime))) tData&lt;-rbind(tData,forTime,ifelseTime) } tData&lt;-tData %&gt;% select(tm:elapsed) %&gt;% gather(tm,cate) names(tData)&lt;-c(&quot;iter&quot;,&quot;cate&quot;,&quot;timeName&quot;,&quot;time&quot;) ggplot(tData,aes(x=iter,y=time,fill=cate,color=cate)) + geom_point(stat=&quot;identity&quot;) tm&lt;-1000000 X&lt;-as.data.frame(matrix(1:tm, ncol=4, dimnames=list(seq(1:(tm/4)), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)))) ifelseTime&lt;-system.time(X$e &lt;- ifelse(X$a == 0, -999, X$b/X$c)) ifelseTime #&gt; 사용자 시스템 elapsed #&gt; 0.04 0.00 0.05 이렇게 for를 사용하지 않고 다른 방법을 사용하는 것으로 벡터연산이 있습니다. 이름이 중요하진 않으니 R이 감당할 수 있는 수준의 데이터를 apply를 통해서 다루는 법을 알아보겠습니다. 3.3 apply류의 함수들 3.3.1 apply apply 함수에 대해서 알아보겠습니다. apply는 행이나 열 방향의 데이터를 한 번에 계산하는데 사용합니다. set.seed(1) ( myMat &lt;- matrix(round(rnorm(16,10),2),4,4) ) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 9.37 10.33 10.58 9.38 #&gt; [2,] 10.18 9.18 9.69 7.79 #&gt; [3,] 9.16 10.49 11.51 11.12 #&gt; [4,] 11.60 10.74 10.39 9.96 위의 mymat에서 각 열의 평균을 구하고 싶으면 이렇게 하면 됩니다. mean(myMat[,1]) #&gt; [1] 10.1 mean(myMat[,2]) #&gt; [1] 10.2 mean(myMat[,3]) #&gt; [1] 10.5 mean(myMat[,4]) #&gt; [1] 9.56 우리는 for를 배웠으니 좀 고쳐 봅시다. for(i in 1:4){ mean(myMat[,i]) } 이게 또 데이터가 따로따로라 c도 해줘야 하는 군요. myMean &lt;- c( mean(myMat[,1]), mean(myMat[,2]), mean(myMat[,3]), mean(myMat[,4]) ) myMean #&gt; [1] 10.08 10.19 10.54 9.56 for를 사용하면 이렇게 됩니다. myMean &lt;- c() for(i in 1:4){ myMean&lt;-c(myMean,mean(myMat[,i])) } myMean #&gt; [1] 10.08 10.19 10.54 9.56 여기서 함수화도 많이 진행하는 것 같더군요. myLoop &lt;- function(somemat) { myMean &lt;- c() for(i in 1:ncol(somemat)){ myMean&lt;-c(myMean,mean(myMat[,i])) } return(myMean) } myLoop(myMat) #&gt; [1] 10.08 10.19 10.54 9.56 근데 이제 열방향 mean 함수를 만드는게 끝났네요. 행방향을 진행하려면 똑같은걸 더 만들어야 합니다. 한 함수에 합쳐서 옵션으로 줘도 좋을 것 같군요. 한번 만들어 보세요. 하지만 apply는 이 걸 한줄에 할 수 있게 해줍니다. apply(myMat, 2, mean) #&gt; [1] 10.08 10.19 10.54 9.56 위에 결과와 비교해 보세요. 위에서 사용한 identical 함수로 두 결과를 비교해 보겠습니다. identical(myLoop(myMat),apply(myMat, 2, mean)) #&gt; [1] TRUE ?apply를 통해 중간의 숫자가 어떤 의미를 가지는지 확인해 보세요. 1은 같은 행끼리의 계산을, 2는 같은 열끼리의 계산을 의미합니다. apply는 3가지 옵션을 가지는데, 첫 번째는 데이터, 두 번째는 계산의 방향, 세 번째는 계산에 사용할 함수입니다. 함수부분은 다양한 함수를 사용할 수 있습니다. apply(myMat,2,class) #&gt; [1] &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; apply(myMat,2,sum) #&gt; [1] 40.3 40.7 42.2 38.2 apply(myMat,2,quantile) #&gt; [,1] [,2] [,3] [,4] #&gt; 0% 9.16 9.18 9.69 7.79 #&gt; 25% 9.32 10.04 10.21 8.98 #&gt; 50% 9.77 10.41 10.48 9.67 #&gt; 75% 10.54 10.55 10.81 10.25 #&gt; 100% 11.60 10.74 11.51 11.12 자주 사용하는 평균이나 합 같은 경우는 함수로도 구현되어 있습니다. rowMeans, colMeans, rowSums, colSums가 그것 입니다. 각각 apply로 어떻게 하면 되는지 생각해 보세요. apply에 적용하는 함수 안에 데이터만 들어가는 함수 이외에 다른 옵션을 지정해야 할 수 있습니다. apply는 ,를 이용해서 다음 옵션으로 사용하는 함수 안의 옵션을 작성할 수 있습니다. myMat[1,4]&lt;-NA apply(myMat,2,sum) #&gt; [1] 40.3 40.7 42.2 NA apply(myMat,2,sum, na.rm = TRUE) #&gt; [1] 40.3 40.7 42.2 28.9 apply에서 계산에 사용할 함수는 사용자가 만들어서 진행할 수도 있고, 임시로 만들 수도 있습니다. naSum &lt;- function(x){ return(sum(x,na.rm = TRUE)) } apply(myMat,2,naSum) #&gt; [1] 40.3 40.7 42.2 28.9 apply(myMat,2,function(x) sum(x,na.rm = TRUE)) #&gt; [1] 40.3 40.7 42.2 28.9 만들어야 할 함수가 복잡하지 않으면 저는 임시로 작성하는 방법을 사용하는 편입니다. 3.3.2 apply-family apply는 lapply, tapply, sapply, mapply 등의 apply-family를 가지고 있습니다. 우선 lapply부터 살펴보겠습니다. 앞에 l이 붙으면서 list 자료형에 대해 apply의 역할을 수행하는 함수라는 의미가 붙었습니다. 결과도 list로 나옵니다. (listData &lt;- list(a = 1, b = 1:3, c = 10:100) ) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 1 2 3 #&gt; #&gt; $c #&gt; [1] 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #&gt; [18] 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #&gt; [35] 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #&gt; [52] 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #&gt; [69] 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #&gt; [86] 95 96 97 98 99 100 lapply(listData, length) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 3 #&gt; #&gt; $c #&gt; [1] 91 lapply(listData, sum) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 6 #&gt; #&gt; $c #&gt; [1] 5005 list 자료형은 사용하시면서 느끼시겠지만 다른 곳에 사용하기 불편한 점이 있습니다. 그래서 다시 list를 푸는 방법으로 unlist를 사용하는데요. ?unlist를 입력해서 내용을 확인해보세요. (listData &lt;- list(a = 1, b = 1:3, c = 10:100) ) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 1 2 3 #&gt; #&gt; $c #&gt; [1] 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #&gt; [18] 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #&gt; [35] 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #&gt; [52] 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #&gt; [69] 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #&gt; [86] 95 96 97 98 99 100 unlist(lapply(listData, length)) #&gt; a b c #&gt; 1 3 91 unlist(lapply(listData, sum)) #&gt; a b c #&gt; 1 6 5005 그런데 입력을 list로 받는 것은 어쩔수 없다고 쳐도, 결과물은 위처럼 vector로 받는 것이 편한 경우가 많습니다. unlist(lapply(데이터,함수))는 sapply와 같은 동작을 합니다. (listData &lt;- list(a = 1, b = 1:3, c = 10:100) ) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 1 2 3 #&gt; #&gt; $c #&gt; [1] 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #&gt; [18] 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #&gt; [35] 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #&gt; [52] 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #&gt; [69] 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #&gt; [86] 95 96 97 98 99 100 sapply(listData, length) #&gt; a b c #&gt; 1 3 91 sapply(listData, sum) #&gt; a b c #&gt; 1 6 5005 이외에도 list안에 list까지 계산하는 rapply, 지정한 이름으로 실행할 수 있는 tapply 등이 있습니다만, 거의 apply나 sapply만 사용한 것 같습니다. 더 궁금하신 사항은 여기를 참고해 주세요. "],
["sql.html", "4 데이터 원본/의존성의 개념과 SQL 문법 익히기 4.1 사전 준비 4.2 데이터를 바라보는 시선 4.3 기본 SQL 문법", " 4 데이터 원본/의존성의 개념과 SQL 문법 익히기 4.1 사전 준비 4.1.1 mariaDB 설치 4.1.1.1 windows 4.1.1.2 mac 4.1.2 GUI 툴 설치 4.1.2.1 heidiSQL(for windows) 4.1.2.2 sequel pro (for mac) 4.2 데이터를 바라보는 시선 4.2.1 데이터 원본 데이터 원본이란 처음 생성된 데이터나 혹은 일정 처리에 대해서 사용자들이 합의하면 처리가 된 이후에 관리하는 데이터를 뜻합니다. 원칙적으로는 의존성이나 변형을 가하지 않은 데이터를 뜻하는데, 실무적으로는 순수한 원본을 관리하는게 쉬운 일은 아닌 것 같습니다. 데이터 원본은 데이터의 신뢰성 때문에 필요합니다. 데이터란 무언가를 측정한 결과물이기 때문에 측정하고자 하는 그 자체는 아닙니다. 그렇다고 측정하지 않으면 분석할 수 없고, 개선할 수 없기 때문에 최대한 그 자체를 측정하려고 노력합니다. 저 또한 사람의 노력으로 작성되는 데이터를 신뢰하지 않는데요. 센서가 기록하는 데이터의 오류가 사람에 비해 낮기 때문입니다. 이렇게 측정된 데이터를 이제 상황에 맞게 가공하게 되는데, 그 가공 과정에서 오류가 발생합니다. 그렇기 때문에 맨 처음 사용하기 시작하는 데이터가 무엇인지를 확정하고, 그 데이터가 원본임을 기록해둘 필요가 있습니다. 데이터 원본은 재현성에도 중요한 개념입니다. 원본이 무엇인지 알리고 그 가공 과정을 재현할 수 있는 방법으로 공개하는 것이 자료의 신뢰를 확보하는 방법입니다. 4.2.2 데이터 의존성 데이터 의존성은 지금 작성한 자료가 얼마나 가공된 데이터를 참고하는지를 뜻합니다. 가공과정이 많을 수록 관점의 차이에서 오는 데이터의 의미 변경과 계산 오류가 많습니다. 최대한 원본을 확보하고, 과정을 단순화하고 오류가 없음을 증명하는 과정이 끊임없이 필요하면서, 의존성을 낮춰야 합니다. 물론 원본을 확보할 수 없을 때는 가공된 데이터를 사용해야 합니다만, 가공된 데이터를 신뢰할 수 있을 때라야 그 데이터를 사용해서 만든 결과물의 신뢰성을 확보할 수 있습니다. 쓰레기를 넣으면 쓰레기가 나온다는 데이터 과학의 격언은 항상 염두해 두어야 합니다. 4.3 기본 SQL 문법 4.3.1 CRUD와 데이터베이스 SQL이란 Structured Query Language의 줄임말입니다. 그럼 query가 뭔지 알아야 하는데, query/질의는 데이터베이스에게 무언가 요청하는 행위를 뜻합니다. 그렇기 때문에 SQL이라고 하면 데이터베이스가 알아들을 수 있는 명령어셋을 의미합니다. 대표적으로 CRUD라고 하는데요. CRUD는 create, read, update, delete의 줄임말로 데이터베이스가 동작하는 형태를 뜻합니다. 특별하게 영어에 의미를 담아 사람들이 사용하는 방식으로 만들기 위해 고려가 많이 되어 있는 언어로 알려져 있습니다. 4.3.1.1 database 일반적으로 db라고 하면 디비 종류로써의 이름을 지칭하는 경우가 많습니다. mysql이나 oracle이 대표적이죠. 오픈소스로 postgresql, mongodb 같은 것이 있습니다. 지금 제목으로 넣은 database는 그 각각의 데이터베이스 안에, 관리하고자 하는 데이터베이스자체를 뜻합니다. database는 이름과 몇 가지 옵션(ex: 인코딩)을 가지고 있고 아래 table을 가지고 있습니다. 4.3.1.2 table table은 데이터베이스안에서 관리하는 데이터를 뜻합니다. 위키 백과를 보면 수직 열과 수평 행의 모델을 사용해 조직된 데이터 요소(값)들의 집합이다. 테이블의 열은 지정된 개수이지만, 행은 무한대로 확장될 수 있다. 각 행은 후보 키라고 식별되는 특정 열 서브셋에 나타나는 값으로 식별된다.라고 합니다. 여기서 열은 field라고도 하는데 attribute가 더 적절한 표현이라고 합니다. R에서의 data frame 입장에서는 column 입니다. 그리고 행은 recode라고도 하며 data frame 입장에서는 row입니다. 설문조사의 결과물을 정리했다고 하면에 각각 item, sample입니다. 4.3.1.3 index 데이터는 각각 의미를 지닐 때 저장하고 사용할 가치를 가집니다. 그렇기 때문에 중복된 데이터를 가지고 있을 필요는 없습니다. 문제는 위에 정의에서도 보듯 column부분은 고정되어 있고, row은 계속 확장할 수 있기 때문에 row방향의 데이터는 계속 쌓여나갑니다. column은 어떤 데이터를 저장할지를 결정하는 곳이라면, row은 그 결정된 방식대로 저장되어 있는 데이터를 뜻합니다. 그리고 그 row 중에 검색용, 혹은 데이터의 위치의 의미를 가지는 것을 index라고 합니다. 4.3.1.4 key 기본적으로 database의 table은 모두 key, 정확히는 primary key가 있습니다. key는 table에서 index의 역할을 하면서 데이터를 모두 유일한 값으로 만드는 역할을 합니다. R에서의 data frame 입장에서는 모든 column이 index역할을 하기도 하며 key는 상황에 따라 만들기도 하고, 신경쓰지 않기도 합니다. index와 primary key 역할은 row number가 기본적으로 수행하고 있다고 생각하시면 좋습니다. 4.3.1.5 create create은 말 그대로 새롭게 만들 때 사용하는 명령입니다. 데이터를 만들거나(row를 추가) 테이블을 만들 때 사용합니다. 테이블을 만든다는 것은 빈 data frame을 만드는 것과 같습니다. 4.3.1.6 read read는 있는 데이터를 읽어서 가져오는 것을 뜻합니다. 아래 자세히 다루겠지만 select, form, where, group by, order by의 형식을 띄구요. 각 어느 column을 가져올지, 어느 table에서 가져올지, 그 중에 어떤 조건을 만족하는 걸 가져올지, 어떻게 묶어서 가져올지, 어떻게 순서를 정할 건지를 명령합니다. 4.3.1.7 update update는 있는 데이터를 고치는 것을 뜻합니다. 파일로 보자면 덮어쓰기 같은 개념이라고 보시면 됩니다. 4.3.1.8 delete delete 또한 의미 그대로 지운다는 뜻입니다. 이 때도 데이터가 테이블을 지우는 것을 의미합니다. 이제 분석에서 많이 쓰는 read에 관련된 문법을 진행하겠습니다. 4.3.2 Read 문법 위에서 잠깐 언급 했듯 read는 데이터를 불러오는 행위를 뜻합니다. 우선 read의 기본 형식은 아래와 같습니다. 하나하나 살펴 보겠습니다. select는 column을 선택하는 구문입니다. 기존에 있는 데이터를 기준으로 어떤 column을 선택할꺼냐를 묻는 곳으로 전체가 필요하면 *를 사용합니다. from은 table을 선택하는 구문입니다. 생각 같아서는 어디 테이블에 어디 컬럼이 좋을 것 같은데, 영문권에서는 이 순서가 더 자연스러운 모양입니다. where는 조건문입니다. 위에 두 경우(table, column)에 해당하는 데이터 전체를 가져오고 싶으면 select * from bank 같이 bank테이블 전체를 가져오는 query를 작성하시면 됩니다. 하지만 그 와중에 데이터들이 조건에 해당하는 일정 부분만 필요하면 그 부분을 where 뒤에 작성하시면 됩니다. group by는 선택한 column으로 묶어서 처리하라는 뜻입니다. 예를 들어 A반의 학생들 평균을 알고 싶으면 A반 학생이라는 조건인 성적만 가져와서 평균을 낼 수도 있지만, 반끼리 데이터를 사용하라고 알려주고 평균을 구할 수도 있습니다. order by는 정렬을 위한 column을 정할 때 사용합니다. db는 table의 데이터를 저장할 때 순서를 고려해서 저장하지 않습니다. 그렇기 때문에 사람의 편의를 위해 순서를 강제하는 방법을 알려주는 것입니다. 하나 더 as는 길게 만들어진 무엇을 줄여서 쉽게 작성하기 위해서 사용합니다. column명이나 table명에서 많이 사용합니다. 위에 있는 내용 중에 중요한 개념이 하나 더 있습니다. 그것은 join인데요. table끼리 합칠 때 사용합니다. 그럼 data frame이랑 기능을 맞춰 보겠습니다. R에서 변수 train에 데이터가 있다고 할때, # for R train # for db select * from train 그럼 column을 선택하는 것은 어떻게 하나요? # for R train[,c(&quot;fecha_dato&quot;,&quot;age&quot;)] # for db select fecha_dato, age from train 이제 row에 조건을 줄 수도 있겠네요? # for R train[train$fecha_dato &gt; 2016-06-28 ,c(&quot;fecha_dato&quot;,&quot;age&quot;)] # for db select fecha_dato, age from train where train.fecha_dato &gt; 2016-07-28 각 성별에 나이 평균도 구할 수 있습니다. # for R data&lt;-train[,c(&quot;sexo&quot;,&quot;age&quot;)] mean(data[data$sexo==&quot;F&quot;,&quot;age&quot;]) mean(data[data$sexo==&quot;M&quot;,&quot;age&quot;]) # for db select sexo, avg(age) from train group by sexo 4.3.3 Join 데이터를 사용하기 편하게 만들기 위해서는 join이 꼭 필요합니다. 여러가지 사정으로 인해서 사용하고자 하는 사람에게 꼭 맞는 형태의 table이 모두 준비되어 있을 수 없기 때문입니다. 그래서 여러 table을 합쳐서 원하는 하나의 table로 만들어야 하는데요. 그렇게 만들어 주는 구문이 바로 join입니다. 우선 join의 종류를 보여드리겠습니다. 많이 헷갈리시는 부분이 있는데 위의 포함관계는 row값, 즉 데이터의 관점에서를 뜻합니다. 두 개의 테이블을 각 column을 합쳐서 데이터를 만드는데, key를 기준으로 column을 합치는 것입니다. 그래서 각 포함관계에 있는 row 방향 데이터를 사용할꺼냐 아니냐를 기준으로 보시면 됩니다. 모두 left, right, inner, outer의 4가지가 있으며 inner을 제외한 3가지는 겹치는 부분을 포함하냐, 제외하냐의 경우까지 따져서 총 7가지 방법으로 join할 수 있습니다. 이 중에 left와 방향만 다른 right을 제외하고 outer에서 inner를 빼는 경우를 제외한 총 4가지를 보도록 하겠습니다. 4.3.3.1 inner inner는 가장 단순하고 이해하기 쉬운 join의 종류입니다. 합치고자 하는 테이블 A, B가 있다고 했을 때, A가 가지고 있는 column과 B가 가지고 있는 column을 key로 지정한 column을 기준으로 컬럼 방향을 합칩니다. 그런데 양 데이터가 전혀 연관이 없다면 합치는게 의미가 없겠죠. 각 테이블의 key의 데이터가 같은 데이터끼리 합치는 과정이 join입니다. inner join은 이렇게 합칠 때 양쪽에 데이터가 모두 있는 경우만을 사용한다고 선언하는 것입니다. 포함관계에서 양쪽에만 있는 데이터가 안쪽에 표시되므로, 안쪽의 데이터만 사용하겠다고 해서 inner 라고 보면 좋을 것 같습니다. select * from A inner join B on A.key = b.key; 위에 잘 보시면 select와 from까지만 사용한 것입니다. from안에 테이블을 지정할 때, 두개의 테이블을 합치는 방법에 대해 작성해서 테이블이 들어갈 위치에 넣었습니다. 여기서 join 구문은 key를 작성하기 위해 on이라는 구문을 사용했습니다. 참, sql은 마지막에 꼭 ;표시를 해줘야 합니다. query 구문이 끝났다는 뜻입니다. 그럼 from에 속한 부분만 다시 보겠습니다. A inner join B on A.key = B.key는 테이블 A와 테이블 B를 inner join 할 껀데 A에서는 key 라는 column을, B에서는 key라는 column을 key로 정해서 같은 데이터끼리 합쳐라는 뜻입니다. 이렇게 합치면 특징이 원래 테이블에 데이터가 NULL이 없다면 NULL인 데이터가 만들어지거나 하지 않습니다. 4.3.3.2 outer outer join은 모든 데이터를 사용한다는 뜻입니다. 그러다 보니 양쪽 테이블에 서로에게 없는 column 데이터는 없으므로 없는 데이터를 모두 null로 표시해주고 데이터를 줍니다. 위에서 inner로 정의한 안 쪽을 제외하면 두 곳의 바깥쪽이 남습니다. 양쪽 모두를 부를 때는 full, 나머지는 아시다시피 left, right입니다. 그런데 mysql이 근간인 mariaDB는 full outer join을 사용할 수 없습니다. 이때는 union으로 우회하는데 여기서는 다루지 않겠습니다. 4.3.3.3 left 이제 outer조인 중 왼쪽을 지칭해서 사용하는 left를 보겠습니다. 우선 왼쪽 테이블을 기준으로 삼습니다. 그리고 양쪽에 같은 데이터를 가지고 있는 column을 key로 선정합니다. 이 key는 테이블 두 개를 합쳤을 때 양쪽 다 있는 데이터이므로 한번만 나오면 되는 데이터 입니다. 그리고 양쪽 테이블에 모두 있는 데이터를 쓸꺼냐 말꺼냐를 결정합니다. 왼쪽의 테이블을 A, 오른쪽의 테이블을 B라고 하고 join을 진행해 보겠습니다. select * from A left join B on A.key = b.key; 위에 처럼 했을때 무슨 의미 인지 같이 짚어 보겠습니다. A 테이블을 왼쪽에 두고 A 테이블과 B 테이블에 있는 key를 기준으로 합치는데 B 테이블에 만약 데이터가 없으면 null로 처리줘 그리고 양쪽 테이블에 있는 데이터를 쓴다 안쓴다 언급이 없었으므로 쓰는 형태로 진행이 되었습니다. 사용하는 것이 기본값이라는 거죠. 이번엔 데이터를 안쓴다고 해볼까요. select * from A left join B on A.key = b.key where B.key is NULL; where에는 데이터에 대한 조건이 들어간다고 설명드렸죠. 이건 B.key가 NULL 인 조건만 데이터를 사용하겠다는 뜻입니다. 그러니까 양쪽 테이블에 모두 있는 데이터는 사용하지 않겠다는 뜻입니다. 반대로 말하면 B 테이블에도 있는 데이터를 빼고 순수하게 A 테이블에만 있는 데이터를 사용하겠다는 뜻입니다. 4.3.4 실습 실습은 github을 클론하셔서 codeForclass4.R 파일을 확인하시면 됩니다. 작은 파일은 저장소에 함께 있고, 큰 파일은 코드내에서 다운로드 받도록 작성했습니다. "],
["tidyr.html", "5 tidy data 개념과 dplyr+tidyr로 데이터 다루기 5.1 단정한 데이터 5.2 dplyr + tidyr 5.3 data.table", " 5 tidy data 개념과 dplyr+tidyr로 데이터 다루기 데이터 분석을 어렵게 하는 여러 이유들이 있습니다. 이게 개발 커뮤니티에서 말하는 기술 부채와 같은 개념이지 않나 생각이 들어 데이터 부채라는 표현을 사용해 보았습니다. 여러 데이터 관련 구루들이 강조하는 바, 데이터 분석의 대부분의 시간(약 80%)은 데이터 수집과 전처리, 정제에 사용됩니다. 계륵 같은 일이죠. garbage in, garbage out; GIGO 이니까요. 데이터가 많지 않았던 시대에는 처리에 시간을 쏟는 것이 너무 당연한 일이었습니다. 하지만 데이터 생성을 설계할 수 있는 입장(서비스 제공자, 마케터 등)에서는 저 시간은 명확하게 비용, 즉 데이터 부채가 되는 것입니다. 이 데이터 부채가 쌓이는 것을 처음부터 막을 수 있도록 데이터가 저장되는 방식에 대해 제안된 개념이 있는데 그것이 tidy data입니다. tidy data란 개념은 Hadley Wickham이 제안했습니다. 5.1 단정한 데이터 이것에 대해 본인이 직접 장문의 설명을 한 것도 있고 R 한글 형태소 분석 패키지인 konlp을 만드신 고감자님의 한글 설명, MS의 데이터 과학자이시자 헬로우 데이터과학의 저자이신 김진영님의 도서 블로그에도 너무 잘 설명되어 있습니다. 추가로 더 내용이 필요하시면 참고하시기 바랍니다. 먼저 tidy data의 개념이 필요한 이유는 컴퓨터에게 분석을 시켜야(!) 하기 때문입니다. 그래서 tidy data는 사람이 눈으로 이해하기에는 적절하지 않을 수 있습니다. 이 곳이 진입장벽이 되기도 하는데, 현재 사용하고 있는 엑셀을 바로 R에 넣고 사용하고 싶은데, 잘 안되는 경우가 많습니다. 그것은 엑셀 파일내 데이터를 사람이 “보기 좋게” 위치했기 때문입니다. 그럼 이제 tidy data의 세 가지 조건을 원문(1)과 고감자님 번역(2), 김진영님 번역(3)순으로 살펴보겠습니다. 1.1 Each variable forms a column. 1.2 각 변수는 개별의 열(column)으로 존재한다. 1.3 각 열에는 개별 속성이 들어간다. 2.1 Each observation forms a row. 2.2 각 관측치는 행(row)를 구성한다. 2.3 각 행에는 개별 관찰 항목이 들어간다. 3.1 Each type of observational unit forms a table. 3.2 각 테이블은 단 하나의 관측기준에 의해서 조직된 데이터를 저장한다. 3.3 각 테이블에는 단일 유형의 데이터가 들어간다. tidydata 1번을 보기 전에 2번을 먼저 보겠습니다.(2&gt;1&gt;3 순으로 쉬워요.) 2번은 단순합니다. 하나의 데이터가 한 줄(행)을 구성해야 한다는 것입니다. 설문지를 예로 들면 한명의 설문 결과가 한 줄로써 저장되는 것이죠. Each observation(개별 관찰)은 하나의 관찰 결과(=설문지 하나)를 뜻합니다. sql이나 data.frame에서 보셨듯 row는 조건으로 데이터를 filter할 수 있는 공간입니다. 그렇기 때문에 각 row는 개별 데이터를 의미합니다. 1번은 2번과 같은 하나가 들어가는 개념이긴 합니다만 하나의 variable, 변수, 개별 속성이라는 점이 조금 어렵습니다. 설문지 예시는 쉽습니다. 하나의 문항이라고 이해하면 되거든요. 그런데 variable이라는게 뭔지를 아는 것이 저는 조금 어려웠습니다. 찾아보니 영어상은 변수, 변할수 있는 수(여기서는 수보다는 값이라고 이해하시면 좋습니다.)인데 그 변수를 대표하는 이름이 컬럼명이라고 생각하면 좋더군요. 그런데 컬럼이 변수에 속하는 값으로 구성되는 경우가 있습니다. 예를들어 날짜가 컬럼명에 들어간 경우죠. 이렇게 생긴 데이터를 wide form이라고 합니다. 날짜는 변수에 들어갈 값이기 때문에 컬럼명을 날짜(date, datetime, when 등)로 정하고 컬럼에 속하는 cell에 날짜가 들어가는 형태로 구성하는 것이 tidy data의 조건을 충족하는 셈이 됩니다. 3번은 단일 테이블이 어떻게 구성되어야 하는지를 알려주는 조건입니다. 김진영님의 번역이 좀 이해하기 쉬운 것 같습니다. 테이블 하나에 하나의 데이터가 들어가야 된다는 뜻인데요, 아래 dplyr과 tidyr을 배우면서 예시들도 같이 보겠습니다. 5.2 dplyr + tidyr dplyr은 plyr 패키지의 data.frame 전용이라는 의미를 가지고 있습니다. plyr은 데이터의 분해 - 적용 - 재조립 전략을 실행할 수 있는 패키지입니다. 이 전략을 data.frame 형태에서 실행하기 위해서 여러 명령어들을 제공합니다. 잘 정돈된 데이터 프레임은 분해 - 적용 - 재조립 전략을 실행하기 쉬우며 데이터를 잘 정돈하기 위해 tidyr 패키지를 함께 사용할 수 있습니다. 최근 ggplot2, dplyr, tidyr 등 tidy data의 개념과 같은 맥락에 있는 패키지들이 하나로 모여 tidyverse 패키지가 되었습니다. library(tidyverse) #&gt; + ggplot2 2.2.1 Date: 2017-08-20 #&gt; + tibble 1.3.3 R: 3.4.0 #&gt; + tidyr 0.6.3 OS: Windows 10 x64 #&gt; + readr 1.1.1 GUI: RTerm #&gt; + purrr 0.2.3 Locale: Korean_Korea.949 #&gt; + dplyr 0.7.2 TZ: Asia/Seoul #&gt; + stringr 1.2.0 #&gt; + forcats 0.2.0 #&gt; Warning: 패키지 &#39;ggplot2&#39;는 R 버전 3.4.1에서 작성되었습니다 #&gt; Warning: 패키지 &#39;tibble&#39;는 R 버전 3.4.1에서 작성되었습니다 #&gt; Warning: 패키지 &#39;tidyr&#39;는 R 버전 3.4.1에서 작성되었습니다 #&gt; Warning: 패키지 &#39;readr&#39;는 R 버전 3.4.1에서 작성되었습니다 #&gt; Warning: 패키지 &#39;purrr&#39;는 R 버전 3.4.1에서 작성되었습니다 #&gt; Warning: 패키지 &#39;dplyr&#39;는 R 버전 3.4.1에서 작성되었습니다 #&gt; Warning: 패키지 &#39;stringr&#39;는 R 버전 3.4.1에서 작성되었습니다 #&gt; Warning: 패키지 &#39;forcats&#39;는 R 버전 3.4.1에서 작성되었습니다 #&gt; ─ Conflicts ────────────────────────── #&gt; * filter(), from dplyr, masks stats::filter() #&gt; * lag(), from dplyr, masks stats::lag() 5.2.1 pipe 연산자 %&gt;% %&gt;%는 함수의 사용 방향을 바꿔서 읽고 이해하기 쉽게 만든 연산자입니다. g(f(y)) == y %&gt;% f() %&gt;% g() 이렇게 사용하고 tidyverse 패키지 전반적으로 사용하는 방식입니다. .으로 앞의 변수의 위치를 지정할 수도 있고, 괄호 안에 작성할 것이 없을 때는 괄호를 생략할 수도 있습니다. g(f(x,y,z)) == y %&gt;% f(x, . , z) %&gt;% g 5.2.2 dplyr 명령어 소개 dplyr에는 행에 조건을 줘서 부분을 불러오는 filter(), 필요한 컬럼만 선택하는 select(), 새로운 컬럼을 계산하는 mutate(), 조건에 따라 재정렬 할 수 있는 arrange(), group_by()와 함께 써서 요약값을 계산할 수 있는 summarise()가 있습니다. group_by()는 mutate(), filter()와도 사용할 수 있습니다. if(!require(nycflights13)) install.packages(&quot;nycflights13&quot;) #&gt; 필요한 패키지를 로딩중입니다: nycflights13 library(nycflights13) flights #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 542 540 2 923 #&gt; 4 2013 1 1 544 545 -1 1004 #&gt; 5 2013 1 1 554 600 -6 812 #&gt; 6 2013 1 1 554 558 -4 740 #&gt; # ... with 3.368e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 첫번째 filter()를 사용해 보겠습니다. filter(flights, month == 1, day == 1) #&gt; # A tibble: 842 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 542 540 2 923 #&gt; 4 2013 1 1 544 545 -1 1004 #&gt; 5 2013 1 1 554 600 -6 812 #&gt; 6 2013 1 1 554 558 -4 740 #&gt; # ... with 836 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, #&gt; # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, #&gt; # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, #&gt; # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; jan1 &lt;- filter(flights, month == 1, day == 1) (dec25 &lt;- filter(flights, month == 12, day == 25)) #&gt; # A tibble: 719 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 12 25 456 500 -4 649 #&gt; 2 2013 12 25 524 515 9 805 #&gt; 3 2013 12 25 542 540 2 832 #&gt; 4 2013 12 25 546 550 -4 1022 #&gt; 5 2013 12 25 556 600 -4 730 #&gt; 6 2013 12 25 557 600 -3 743 #&gt; # ... with 713 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, #&gt; # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, #&gt; # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, #&gt; # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; logical filter(flights, month == 11 | month == 12) #&gt; # A tibble: 55,403 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 11 1 5 2359 6 352 #&gt; 2 2013 11 1 35 2250 105 123 #&gt; 3 2013 11 1 455 500 -5 641 #&gt; 4 2013 11 1 539 545 -6 856 #&gt; 5 2013 11 1 542 545 -3 831 #&gt; 6 2013 11 1 549 600 -11 912 #&gt; # ... with 5.54e+04 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; nov_dec &lt;- filter(flights, month %in% c(11, 12)) nov_dec #&gt; # A tibble: 55,403 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 11 1 5 2359 6 352 #&gt; 2 2013 11 1 35 2250 105 123 #&gt; 3 2013 11 1 455 500 -5 641 #&gt; 4 2013 11 1 539 545 -6 856 #&gt; 5 2013 11 1 542 545 -3 831 #&gt; 6 2013 11 1 549 600 -11 912 #&gt; # ... with 5.54e+04 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; filter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120)) #&gt; # A tibble: 316,050 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 542 540 2 923 #&gt; 4 2013 1 1 544 545 -1 1004 #&gt; 5 2013 1 1 554 600 -6 812 #&gt; 6 2013 1 1 554 558 -4 740 #&gt; # ... with 3.16e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; filter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120) #&gt; # A tibble: 316,050 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 542 540 2 923 #&gt; 4 2013 1 1 544 545 -1 1004 #&gt; 5 2013 1 1 554 600 -6 812 #&gt; 6 2013 1 1 554 558 -4 740 #&gt; # ... with 3.16e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; arrange()는 조건을 바탕으로 정렬을 다시 해줍니다. arrange(flights, year, month, day) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 542 540 2 923 #&gt; 4 2013 1 1 544 545 -1 1004 #&gt; 5 2013 1 1 554 600 -6 812 #&gt; 6 2013 1 1 554 558 -4 740 #&gt; # ... with 3.368e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; arrange(flights, desc(arr_delay)) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 #&gt; 2 2013 6 15 1432 1935 1137 1607 #&gt; 3 2013 1 10 1121 1635 1126 1239 #&gt; 4 2013 9 20 1139 1845 1014 1457 #&gt; 5 2013 7 22 845 1600 1005 1044 #&gt; 6 2013 4 10 1100 1900 960 1342 #&gt; # ... with 3.368e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; df &lt;- tibble(x = c(5, 2, NA)) arrange(df, x) #&gt; # A tibble: 3 x 1 #&gt; x #&gt; &lt;dbl&gt; #&gt; 1 2 #&gt; 2 5 #&gt; 3 NA arrange(df, desc(x)) #&gt; # A tibble: 3 x 1 #&gt; x #&gt; &lt;dbl&gt; #&gt; 1 5 #&gt; 2 2 #&gt; 3 NA select()는 컬럼을 선택하는 함수라고 했습니다. select(flights, year, month, day) #&gt; # A tibble: 336,776 x 3 #&gt; year month day #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 #&gt; 2 2013 1 1 #&gt; 3 2013 1 1 #&gt; 4 2013 1 1 #&gt; 5 2013 1 1 #&gt; 6 2013 1 1 #&gt; # ... with 3.368e+05 more rows select(flights, year:day) #&gt; # A tibble: 336,776 x 3 #&gt; year month day #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 #&gt; 2 2013 1 1 #&gt; 3 2013 1 1 #&gt; 4 2013 1 1 #&gt; 5 2013 1 1 #&gt; 6 2013 1 1 #&gt; # ... with 3.368e+05 more rows select(flights, -(year:day)) #&gt; # A tibble: 336,776 x 16 #&gt; dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay #&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 517 515 2 830 819 11 #&gt; 2 533 529 4 850 830 20 #&gt; 3 542 540 2 923 850 33 #&gt; 4 544 545 -1 1004 1022 -18 #&gt; 5 554 600 -6 812 837 -25 #&gt; 6 554 558 -4 740 728 12 #&gt; # ... with 3.368e+05 more rows, and 10 more variables: carrier &lt;chr&gt;, #&gt; # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; select와 함께 사용하는 함수로 starts_with(&quot;abc&quot;), ends_with(&quot;xyz&quot;), contains(&quot;ijk&quot;), matches(&quot;(.)\\\\1&quot;), num_range(&quot;x&quot;, 1:3)등을 들 수 있습니다. ?select를 실행해서 자세한 사항을 확인해보세요. rename()은 컬럼의 이름을 바꾸는 함수고, everything()은 선택한 것 이외에 전부를 뜻합니다. rename(flights, tail_num = tailnum) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 542 540 2 923 #&gt; 4 2013 1 1 544 545 -1 1004 #&gt; 5 2013 1 1 554 600 -6 812 #&gt; 6 2013 1 1 554 558 -4 740 #&gt; # ... with 3.368e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tail_num &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; select(flights, time_hour, air_time, everything()) #&gt; # A tibble: 336,776 x 19 #&gt; time_hour air_time year month day dep_time sched_dep_time #&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013-01-01 05:00:00 227 2013 1 1 517 515 #&gt; 2 2013-01-01 05:00:00 227 2013 1 1 533 529 #&gt; 3 2013-01-01 05:00:00 160 2013 1 1 542 540 #&gt; 4 2013-01-01 05:00:00 183 2013 1 1 544 545 #&gt; 5 2013-01-01 06:00:00 116 2013 1 1 554 600 #&gt; 6 2013-01-01 05:00:00 150 2013 1 1 554 558 #&gt; # ... with 3.368e+05 more rows, and 12 more variables: dep_delay &lt;dbl&gt;, #&gt; # arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, #&gt; # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, distance &lt;dbl&gt;, #&gt; # hour &lt;dbl&gt;, minute &lt;dbl&gt; mutate()는 새로운 변수 계산을 위해서 필요합니다. flights_sml &lt;- select(flights, year:day, ends_with(&quot;delay&quot;), distance, air_time ) mutate(flights_sml, gain = arr_delay - dep_delay, speed = distance / air_time * 60 ) #&gt; # A tibble: 336,776 x 9 #&gt; year month day dep_delay arr_delay distance air_time gain speed #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 2 11 1400 227 9 370 #&gt; 2 2013 1 1 4 20 1416 227 16 374 #&gt; 3 2013 1 1 2 33 1089 160 31 408 #&gt; 4 2013 1 1 -1 -18 1576 183 -17 517 #&gt; 5 2013 1 1 -6 -25 762 116 -19 394 #&gt; 6 2013 1 1 -4 12 719 150 16 288 #&gt; # ... with 3.368e+05 more rows mutate(flights_sml, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours ) #&gt; # A tibble: 336,776 x 10 #&gt; year month day dep_delay arr_delay distance air_time gain hours #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 2 11 1400 227 9 3.78 #&gt; 2 2013 1 1 4 20 1416 227 16 3.78 #&gt; 3 2013 1 1 2 33 1089 160 31 2.67 #&gt; 4 2013 1 1 -1 -18 1576 183 -17 3.05 #&gt; 5 2013 1 1 -6 -25 762 116 -19 1.93 #&gt; 6 2013 1 1 -4 12 719 150 16 2.50 #&gt; # ... with 3.368e+05 more rows, and 1 more variables: gain_per_hour &lt;dbl&gt; transmute(flights, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours ) #&gt; # A tibble: 336,776 x 3 #&gt; gain hours gain_per_hour #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 9 3.78 2.38 #&gt; 2 16 3.78 4.23 #&gt; 3 31 2.67 11.62 #&gt; 4 -17 3.05 -5.57 #&gt; 5 -19 1.93 -9.83 #&gt; 6 16 2.50 6.40 #&gt; # ... with 3.368e+05 more rows 특별히 mutate()와 함께 사용하는 함수중에 lag()와 lead()를 소개할까 합니다. (x &lt;- 1:10) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 lag(x) #&gt; [1] NA 1 2 3 4 5 6 7 8 9 lead(x) #&gt; [1] 2 3 4 5 6 7 8 9 10 NA mutate()가 각 행에 대한 계산 결과를 하나의 컬럼으로 만들어 주는 것이라면 summarise()는 일정 조건(대부분 group_by()를 이용한 그룹화)에 해당하는 계산을 수행해줍니다. summarise(flights, delay = mean(dep_delay, na.rm = TRUE)) #&gt; # A tibble: 1 x 1 #&gt; delay #&gt; &lt;dbl&gt; #&gt; 1 12.6 by_day &lt;- group_by(flights, year, month, day) summarise(by_day, delay = mean(dep_delay, na.rm = TRUE)) #&gt; # A tibble: 365 x 4 #&gt; # Groups: year, month [?] #&gt; year month day delay #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 11.55 #&gt; 2 2013 1 2 13.86 #&gt; 3 2013 1 3 10.99 #&gt; 4 2013 1 4 8.95 #&gt; 5 2013 1 5 5.73 #&gt; 6 2013 1 6 7.15 #&gt; # ... with 359 more rows daily &lt;- group_by(flights, year, month, day) (per_day &lt;- summarise(daily, flights = n())) #&gt; # A tibble: 365 x 4 #&gt; # Groups: year, month [?] #&gt; year month day flights #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 842 #&gt; 2 2013 1 2 943 #&gt; 3 2013 1 3 914 #&gt; 4 2013 1 4 915 #&gt; 5 2013 1 5 720 #&gt; 6 2013 1 6 832 #&gt; # ... with 359 more rows (per_month &lt;- summarise(per_day, flights = sum(flights))) #&gt; # A tibble: 12 x 3 #&gt; # Groups: year [?] #&gt; year month flights #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 27004 #&gt; 2 2013 2 24951 #&gt; 3 2013 3 28834 #&gt; 4 2013 4 28330 #&gt; 5 2013 5 28796 #&gt; 6 2013 6 28243 #&gt; # ... with 6 more rows (per_year &lt;- summarise(per_month, flights = sum(flights))) #&gt; # A tibble: 1 x 2 #&gt; year flights #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 336776 daily %&gt;% ungroup() %&gt;% summarise(flights = n()) #&gt; # A tibble: 1 x 1 #&gt; flights #&gt; &lt;int&gt; #&gt; 1 336776 group_by()를 mutate(), filter()와도 사용할 수 있다고 했습니다. flights_sml %&gt;% group_by(year, month, day) %&gt;% filter(rank(desc(arr_delay)) &lt; 10) #&gt; # A tibble: 3,306 x 7 #&gt; # Groups: year, month, day [365] #&gt; year month day dep_delay arr_delay distance air_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 853 851 184 41 #&gt; 2 2013 1 1 290 338 1134 213 #&gt; 3 2013 1 1 260 263 266 46 #&gt; 4 2013 1 1 157 174 213 60 #&gt; 5 2013 1 1 216 222 708 121 #&gt; 6 2013 1 1 255 250 589 115 #&gt; # ... with 3,300 more rows popular_dests &lt;- flights %&gt;% group_by(dest) %&gt;% filter(n() &gt; 365) popular_dests #&gt; # A tibble: 332,577 x 19 #&gt; # Groups: dest [77] #&gt; year month day dep_time sched_dep_time dep_delay arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 #&gt; 2 2013 1 1 533 529 4 850 #&gt; 3 2013 1 1 542 540 2 923 #&gt; 4 2013 1 1 544 545 -1 1004 #&gt; 5 2013 1 1 554 600 -6 812 #&gt; 6 2013 1 1 554 558 -4 740 #&gt; # ... with 3.326e+05 more rows, and 12 more variables: #&gt; # sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, #&gt; # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; popular_dests %&gt;% filter(arr_delay &gt; 0) %&gt;% mutate(prop_delay = arr_delay / sum(arr_delay)) %&gt;% select(year:day, dest, arr_delay, prop_delay) #&gt; # A tibble: 131,106 x 6 #&gt; # Groups: dest [77] #&gt; year month day dest arr_delay prop_delay #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 IAH 11 1.11e-04 #&gt; 2 2013 1 1 IAH 20 2.01e-04 #&gt; 3 2013 1 1 MIA 33 2.35e-04 #&gt; 4 2013 1 1 ORD 12 4.24e-05 #&gt; 5 2013 1 1 FLL 19 9.38e-05 #&gt; 6 2013 1 1 ORD 8 2.83e-05 #&gt; # ... with 1.311e+05 more rows 5.2.3 tidyr 명령어 소개 tidyr에는 long form을 wide form으로 바꿔주는 spread(), 반대로 wide form을 long form으로 바꿔주는 gather(), 여러 의미를 지닌 데이터를 특정 글자를 기준으로 분리해 주는 seperate(), 그 반대로 합치는 unite(), 데이터를 분리하는 폼을 지정해 줄 수 있는 extract()가 있습니다. 우선 내장된 데이터를 소개하겠습니다. table1 #&gt; # A tibble: 6 x 4 #&gt; country year cases population #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghanistan 1999 745 19987071 #&gt; 2 Afghanistan 2000 2666 20595360 #&gt; 3 Brazil 1999 37737 172006362 #&gt; 4 Brazil 2000 80488 174504898 #&gt; 5 China 1999 212258 1272915272 #&gt; 6 China 2000 213766 1280428583 table2 #&gt; # A tibble: 12 x 4 #&gt; country year type count #&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Afghanistan 1999 cases 745 #&gt; 2 Afghanistan 1999 population 19987071 #&gt; 3 Afghanistan 2000 cases 2666 #&gt; 4 Afghanistan 2000 population 20595360 #&gt; 5 Brazil 1999 cases 37737 #&gt; 6 Brazil 1999 population 172006362 #&gt; # ... with 6 more rows table3 #&gt; # A tibble: 6 x 3 #&gt; country year rate #&gt; * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 Afghanistan 1999 745/19987071 #&gt; 2 Afghanistan 2000 2666/20595360 #&gt; 3 Brazil 1999 37737/172006362 #&gt; 4 Brazil 2000 80488/174504898 #&gt; 5 China 1999 212258/1272915272 #&gt; 6 China 2000 213766/1280428583 table4a #&gt; # A tibble: 3 x 3 #&gt; country `1999` `2000` #&gt; * &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghanistan 745 2666 #&gt; 2 Brazil 37737 80488 #&gt; 3 China 212258 213766 table4b #&gt; # A tibble: 3 x 3 #&gt; country `1999` `2000` #&gt; * &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghanistan 19987071 20595360 #&gt; 2 Brazil 172006362 174504898 #&gt; 3 China 1272915272 1280428583 이제 많이 사용하게 될 gather() 함수를 보겠습니다. table4a #&gt; # A tibble: 3 x 3 #&gt; country `1999` `2000` #&gt; * &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghanistan 745 2666 #&gt; 2 Brazil 37737 80488 #&gt; 3 China 212258 213766 table4a %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;cases&quot;) #&gt; # A tibble: 6 x 3 #&gt; country year cases #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Afghanistan 1999 745 #&gt; 2 Brazil 1999 37737 #&gt; 3 China 1999 212258 #&gt; 4 Afghanistan 2000 2666 #&gt; 5 Brazil 2000 80488 #&gt; 6 China 2000 213766 gather 이번엔 반대과정인 spread()를 보겠습니다. table2 #&gt; # A tibble: 12 x 4 #&gt; country year type count #&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 Afghanistan 1999 cases 745 #&gt; 2 Afghanistan 1999 population 19987071 #&gt; 3 Afghanistan 2000 cases 2666 #&gt; 4 Afghanistan 2000 population 20595360 #&gt; 5 Brazil 1999 cases 37737 #&gt; 6 Brazil 1999 population 172006362 #&gt; # ... with 6 more rows spread(table2, key = type, value = count) #&gt; # A tibble: 6 x 4 #&gt; country year cases population #&gt; * &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghanistan 1999 745 19987071 #&gt; 2 Afghanistan 2000 2666 20595360 #&gt; 3 Brazil 1999 37737 172006362 #&gt; 4 Brazil 2000 80488 174504898 #&gt; 5 China 1999 212258 1272915272 #&gt; 6 China 2000 213766 1280428583 spread 한 셀에 여러 값이 있어서 나눠야 할 때는 seperate()를 사용합니다. sep옵션을 주지 않아도, 간단한 것은 알아서 나눠줍니다. table3 #&gt; # A tibble: 6 x 3 #&gt; country year rate #&gt; * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 Afghanistan 1999 745/19987071 #&gt; 2 Afghanistan 2000 2666/20595360 #&gt; 3 Brazil 1999 37737/172006362 #&gt; 4 Brazil 2000 80488/174504898 #&gt; 5 China 1999 212258/1272915272 #&gt; 6 China 2000 213766/1280428583 table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;)) #&gt; # A tibble: 6 x 4 #&gt; country year cases population #&gt; * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Afghanistan 1999 745 19987071 #&gt; 2 Afghanistan 2000 2666 20595360 #&gt; 3 Brazil 1999 37737 172006362 #&gt; 4 Brazil 2000 80488 174504898 #&gt; 5 China 1999 212258 1272915272 #&gt; 6 China 2000 213766 1280428583 table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), convert = TRUE) #&gt; # A tibble: 6 x 4 #&gt; country year cases population #&gt; * &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Afghanistan 1999 745 19987071 #&gt; 2 Afghanistan 2000 2666 20595360 #&gt; 3 Brazil 1999 37737 172006362 #&gt; 4 Brazil 2000 80488 174504898 #&gt; 5 China 1999 212258 1272915272 #&gt; 6 China 2000 213766 1280428583 table3 %&gt;% separate(year, into = c(&quot;century&quot;, &quot;year&quot;), sep = 2) #&gt; # A tibble: 6 x 4 #&gt; country century year rate #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Afghanistan 19 99 745/19987071 #&gt; 2 Afghanistan 20 00 2666/20595360 #&gt; 3 Brazil 19 99 37737/172006362 #&gt; 4 Brazil 20 00 80488/174504898 #&gt; 5 China 19 99 212258/1272915272 #&gt; 6 China 20 00 213766/1280428583 unite()는 합쳐주는 seperate()와는 반대의 기능을 가진 함수입니다. table5 %&gt;% unite(new, century, year) #&gt; # A tibble: 6 x 3 #&gt; country new rate #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Afghanistan 19_99 745/19987071 #&gt; 2 Afghanistan 20_00 2666/20595360 #&gt; 3 Brazil 19_99 37737/172006362 #&gt; 4 Brazil 20_00 80488/174504898 #&gt; 5 China 19_99 212258/1272915272 #&gt; 6 China 20_00 213766/1280428583 table5 %&gt;% unite(new, century, year, sep = &quot;&quot;) #&gt; # A tibble: 6 x 3 #&gt; country new rate #&gt; * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Afghanistan 1999 745/19987071 #&gt; 2 Afghanistan 2000 2666/20595360 #&gt; 3 Brazil 1999 37737/172006362 #&gt; 4 Brazil 2000 80488/174504898 #&gt; 5 China 1999 212258/1272915272 #&gt; 6 China 2000 213766/1280428583 5.2.4 dplyr과 join {#dplyr&amp;join} dplyr에는 join() 기능도 있습니다. 데이터를 먼저 소개하겠습니다. airlines #&gt; # A tibble: 16 x 2 #&gt; carrier name #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 9E Endeavor Air Inc. #&gt; 2 AA American Airlines Inc. #&gt; 3 AS Alaska Airlines Inc. #&gt; 4 B6 JetBlue Airways #&gt; 5 DL Delta Air Lines Inc. #&gt; 6 EV ExpressJet Airlines Inc. #&gt; # ... with 10 more rows airports #&gt; # A tibble: 1,458 x 8 #&gt; faa name lat lon alt tz dst #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 04G Lansdowne Airport 41.1 -80.6 1044 -5 A #&gt; 2 06A Moton Field Municipal Airport 32.5 -85.7 264 -6 A #&gt; 3 06C Schaumburg Regional 42.0 -88.1 801 -6 A #&gt; 4 06N Randall Airport 41.4 -74.4 523 -5 A #&gt; 5 09J Jekyll Island Airport 31.1 -81.4 11 -5 A #&gt; 6 0A9 Elizabethton Municipal Airport 36.4 -82.2 1593 -5 A #&gt; # ... with 1,452 more rows, and 1 more variables: tzone &lt;chr&gt; planes #&gt; # A tibble: 3,322 x 9 #&gt; tailnum year type manufacturer model engines #&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 N10156 2004 Fixed wing multi engine EMBRAER EMB-145XR 2 #&gt; 2 N102UW 1998 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 #&gt; 3 N103US 1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 #&gt; 4 N104UW 1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 #&gt; 5 N10575 2002 Fixed wing multi engine EMBRAER EMB-145LR 2 #&gt; 6 N105UW 1999 Fixed wing multi engine AIRBUS INDUSTRIE A320-214 2 #&gt; # ... with 3,316 more rows, and 3 more variables: seats &lt;int&gt;, #&gt; # speed &lt;int&gt;, engine &lt;chr&gt; weather #&gt; # A tibble: 26,130 x 15 #&gt; origin year month day hour temp dewp humid wind_dir wind_speed #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 EWR 2013 1 1 0 37.0 21.9 54.0 230 10.4 #&gt; 2 EWR 2013 1 1 1 37.0 21.9 54.0 230 13.8 #&gt; 3 EWR 2013 1 1 2 37.9 21.9 52.1 230 12.7 #&gt; 4 EWR 2013 1 1 3 37.9 23.0 54.5 230 13.8 #&gt; 5 EWR 2013 1 1 4 37.9 24.1 57.0 240 15.0 #&gt; 6 EWR 2013 1 1 6 39.0 26.1 59.4 270 10.4 #&gt; # ... with 2.612e+04 more rows, and 5 more variables: wind_gust &lt;dbl&gt;, #&gt; # precip &lt;dbl&gt;, pressure &lt;dbl&gt;, visib &lt;dbl&gt;, time_hour &lt;dttm&gt; %&gt;%와 join() 명령어로 쉽게 데이터를 합칠 수 있습니다. flights2 &lt;- flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) flights2 #&gt; # A tibble: 336,776 x 8 #&gt; year month day hour origin dest tailnum carrier #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA #&gt; 2 2013 1 1 5 LGA IAH N24211 UA #&gt; 3 2013 1 1 5 JFK MIA N619AA AA #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 #&gt; 5 2013 1 1 6 LGA ATL N668DN DL #&gt; 6 2013 1 1 5 EWR ORD N39463 UA #&gt; # ... with 3.368e+05 more rows flights2 %&gt;% select(-origin, -dest) %&gt;% left_join(airlines, by = &quot;carrier&quot;) #&gt; # A tibble: 336,776 x 7 #&gt; year month day hour tailnum carrier name #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 2013 1 1 5 N14228 UA United Air Lines Inc. #&gt; 2 2013 1 1 5 N24211 UA United Air Lines Inc. #&gt; 3 2013 1 1 5 N619AA AA American Airlines Inc. #&gt; 4 2013 1 1 5 N804JB B6 JetBlue Airways #&gt; 5 2013 1 1 6 N668DN DL Delta Air Lines Inc. #&gt; 6 2013 1 1 5 N39463 UA United Air Lines Inc. #&gt; # ... with 3.368e+05 more rows flights2 %&gt;% select(-origin, -dest) %&gt;% mutate(name = airlines$name[match(carrier, airlines$carrier)]) #&gt; # A tibble: 336,776 x 7 #&gt; year month day hour tailnum carrier name #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 2013 1 1 5 N14228 UA United Air Lines Inc. #&gt; 2 2013 1 1 5 N24211 UA United Air Lines Inc. #&gt; 3 2013 1 1 5 N619AA AA American Airlines Inc. #&gt; 4 2013 1 1 5 N804JB B6 JetBlue Airways #&gt; 5 2013 1 1 6 N668DN DL Delta Air Lines Inc. #&gt; 6 2013 1 1 5 N39463 UA United Air Lines Inc. #&gt; # ... with 3.368e+05 more rows key를 선정해주는 것과 아닌 것이 어떻게 다른지 봐주세요. flights2 %&gt;% left_join(weather) #&gt; Joining, by = c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;origin&quot;) #&gt; # A tibble: 336,776 x 18 #&gt; year month day hour origin dest tailnum carrier temp dewp humid #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA NA NA NA #&gt; 2 2013 1 1 5 LGA IAH N24211 UA NA NA NA #&gt; 3 2013 1 1 5 JFK MIA N619AA AA NA NA NA #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 NA NA NA #&gt; 5 2013 1 1 6 LGA ATL N668DN DL 39.9 26.1 57.3 #&gt; 6 2013 1 1 5 EWR ORD N39463 UA NA NA NA #&gt; # ... with 3.368e+05 more rows, and 7 more variables: wind_dir &lt;dbl&gt;, #&gt; # wind_speed &lt;dbl&gt;, wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, pressure &lt;dbl&gt;, #&gt; # visib &lt;dbl&gt;, time_hour &lt;dttm&gt; flights2 %&gt;% left_join(planes, by = &quot;tailnum&quot;) #&gt; # A tibble: 336,776 x 16 #&gt; year.x month day hour origin dest tailnum carrier year.y #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA 1999 #&gt; 2 2013 1 1 5 LGA IAH N24211 UA 1998 #&gt; 3 2013 1 1 5 JFK MIA N619AA AA 1990 #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 2012 #&gt; 5 2013 1 1 6 LGA ATL N668DN DL 1991 #&gt; 6 2013 1 1 5 EWR ORD N39463 UA 2012 #&gt; # ... with 3.368e+05 more rows, and 7 more variables: type &lt;chr&gt;, #&gt; # manufacturer &lt;chr&gt;, model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, #&gt; # speed &lt;int&gt;, engine &lt;chr&gt; 왼쪽 테이블과 오른쪽 테이블의 어떤 key를 기준으로 join()할 건지 지정할 수 있습니다. flights2 %&gt;% left_join(airports, c(&quot;dest&quot; = &quot;faa&quot;)) #&gt; # A tibble: 336,776 x 15 #&gt; year month day hour origin dest tailnum carrier #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA #&gt; 2 2013 1 1 5 LGA IAH N24211 UA #&gt; 3 2013 1 1 5 JFK MIA N619AA AA #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 #&gt; 5 2013 1 1 6 LGA ATL N668DN DL #&gt; 6 2013 1 1 5 EWR ORD N39463 UA #&gt; # ... with 3.368e+05 more rows, and 7 more variables: name &lt;chr&gt;, #&gt; # lat &lt;dbl&gt;, lon &lt;dbl&gt;, alt &lt;int&gt;, tz &lt;dbl&gt;, dst &lt;chr&gt;, tzone &lt;chr&gt; flights2 %&gt;% left_join(airports, c(&quot;origin&quot; = &quot;faa&quot;)) #&gt; # A tibble: 336,776 x 15 #&gt; year month day hour origin dest tailnum carrier name #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 2013 1 1 5 EWR IAH N14228 UA Newark Liberty Intl #&gt; 2 2013 1 1 5 LGA IAH N24211 UA La Guardia #&gt; 3 2013 1 1 5 JFK MIA N619AA AA John F Kennedy Intl #&gt; 4 2013 1 1 5 JFK BQN N804JB B6 John F Kennedy Intl #&gt; 5 2013 1 1 6 LGA ATL N668DN DL La Guardia #&gt; 6 2013 1 1 5 EWR ORD N39463 UA Newark Liberty Intl #&gt; # ... with 3.368e+05 more rows, and 6 more variables: lat &lt;dbl&gt;, #&gt; # lon &lt;dbl&gt;, alt &lt;int&gt;, tz &lt;dbl&gt;, dst &lt;chr&gt;, tzone &lt;chr&gt; join() 함수는 base::merge(), SQL과 비교할 수 있습니다. inner_join(x, y) == merge(x, y) left_join(x, y) == merge(x, y, all.x = TRUE) right_join(x, y) == merge(x, y, all.y = TRUE), full_join(x, y) == merge(x, y, all.x = TRUE, all.y = TRUE) inner_join(x, y, by = &quot;z&quot;) == SELECT * FROM x INNER JOIN y ON x.z = y.z left_join(x, y, by = &quot;z&quot;) == SELECT * FROM x LEFT OUTER JOIN y ON x.z = y.z right_join(x, y, by = &quot;z&quot;) == SELECT * FROM x RIGHT OUTER JOIN y ON x.z = y.z full_join(x, y, by = &quot;z&quot;) == SELECT * FROM x FULL OUTER JOIN y ON x.z = y.z 5.2.5 dplyr과 SQL dplyr은 데이터베이스에게 SQL 쿼리를 사용하는 것처럼 사용할 수 있습니다. 이곳에 잘 설명되어 있으니 참고하시기 바랍니다. library(dplyr) library(RSQLite) library(RMySQL) #&gt; 필요한 패키지를 로딩중입니다: DBI #&gt; 필요한 패키지를 로딩중입니다: methods #&gt; #&gt; 다음의 패키지를 부착합니다: &#39;RMySQL&#39; #&gt; The following object is masked from &#39;package:RSQLite&#39;: #&gt; #&gt; isIdCurrent sqlite_db = src_sqlite(&#39;sqlite_db.sqlite3&#39;, create = T) copy_to(sqlite_db, mtcars) src_tbls(sqlite_db) #&gt; [1] &quot;mtcars&quot; &quot;sqlite_stat1&quot; &quot;sqlite_stat4&quot; tbl(sqlite_db, &#39;mtcars&#39;) #&gt; # Source: table&lt;mtcars&gt; [?? x 11] #&gt; # Database: sqlite 3.19.3 #&gt; # [C:\\Users\\mrchypark\\Documents\\project\\data_camp_dabrp\\sqlite_db.sqlite3] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 #&gt; 2 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 21.4 6 258 110 3.08 3.21 19.4 1 0 3 1 #&gt; 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; # ... with more rows tbl(sqlite_db, sql(&#39;SELECT * FROM mtcars&#39;)) #&gt; # Source: SQL [?? x 11] #&gt; # Database: sqlite 3.19.3 #&gt; # [C:\\Users\\mrchypark\\Documents\\project\\data_camp_dabrp\\sqlite_db.sqlite3] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 #&gt; 2 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 21.4 6 258 110 3.08 3.21 19.4 1 0 3 1 #&gt; 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 #&gt; 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 #&gt; # ... with more rows iris_db = tbl(sqlite_db, &#39;mtcars&#39;) iris_db %&gt;% filter(mpg &gt; 20) #&gt; # Source: lazy query [?? x 11] #&gt; # Database: sqlite 3.19.3 #&gt; # [C:\\Users\\mrchypark\\Documents\\project\\data_camp_dabrp\\sqlite_db.sqlite3] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21.0 6 160 110 3.90 2.62 16.5 0 1 4 4 #&gt; 2 21.0 6 160 110 3.90 2.88 17.0 0 1 4 4 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 4 21.4 6 258 110 3.08 3.21 19.4 1 0 3 1 #&gt; 5 24.4 4 147 62 3.69 3.19 20.0 1 0 4 2 #&gt; 6 22.8 4 141 95 3.92 3.15 22.9 1 0 4 2 #&gt; # ... with more rows sql_db = src_mysql(dbname=&quot;bank&quot;,user = &quot;root&quot;,password = &quot;XXXXX&quot;) sql_db 5.3 data.table data.table은 지금까지와는 조금 다른 문법을 가지고 있습니다. fread와 fwrite이라는 강력한 IO함수를 가지고 있으며 data.table은 패키지 명이면서 data.frame과 호환되는 자료형이기도 합니다. 자세한 내용은 여기를 참고해 주세요. library(data.table) #&gt; #&gt; 다음의 패키지를 부착합니다: &#39;data.table&#39; #&gt; The following objects are masked from &#39;package:dplyr&#39;: #&gt; #&gt; between, first, last #&gt; The following object is masked from &#39;package:purrr&#39;: #&gt; #&gt; transpose url&lt;-&quot;https://github.com/arunsrinivasan/flights/wiki/NYCflights14/flights14.csv&quot; dir.create(&quot;./data&quot;,showWarnings = F) download.file(url,destfile = &quot;./data/flights14.csv&quot;) system.time(flights &lt;- read.csv(&quot;./data/flights14.csv&quot;)) #&gt; 사용자 시스템 elapsed #&gt; 5.04 0.16 5.92 system.time(flights &lt;- fread(&quot;./data/flights14.csv&quot;)) #&gt; 사용자 시스템 elapsed #&gt; 0.30 0.03 0.34 flights #&gt; year month day dep_time dep_delay arr_time arr_delay cancelled #&gt; 1: 2014 1 1 914 14 1238 13 0 #&gt; 2: 2014 1 1 1157 -3 1523 13 0 #&gt; 3: 2014 1 1 1902 2 2224 9 0 #&gt; 4: 2014 1 1 722 -8 1014 -26 0 #&gt; 5: 2014 1 1 1347 2 1706 1 0 #&gt; --- #&gt; 253312: 2014 10 31 1459 1 1747 -30 0 #&gt; 253313: 2014 10 31 854 -5 1147 -14 0 #&gt; 253314: 2014 10 31 1102 -8 1311 16 0 #&gt; 253315: 2014 10 31 1106 -4 1325 15 0 #&gt; 253316: 2014 10 31 824 -5 1045 1 0 #&gt; carrier tailnum flight origin dest air_time distance hour min #&gt; 1: AA N338AA 1 JFK LAX 359 2475 9 14 #&gt; 2: AA N335AA 3 JFK LAX 363 2475 11 57 #&gt; 3: AA N327AA 21 JFK LAX 351 2475 19 2 #&gt; 4: AA N3EHAA 29 LGA PBI 157 1035 7 22 #&gt; 5: AA N319AA 117 JFK LAX 350 2475 13 47 #&gt; --- #&gt; 253312: UA N23708 1744 LGA IAH 201 1416 14 59 #&gt; 253313: UA N33132 1758 EWR IAH 189 1400 8 54 #&gt; 253314: MQ N827MQ 3591 LGA RDU 83 431 11 2 #&gt; 253315: MQ N511MQ 3592 LGA DTW 75 502 11 6 #&gt; 253316: MQ N813MQ 3599 LGA SDF 110 659 8 24 dim(flights) #&gt; [1] 253316 17 ans &lt;- flights[origin == &quot;JFK&quot; &amp; month == 6L] head(ans) #&gt; year month day dep_time dep_delay arr_time arr_delay cancelled carrier #&gt; 1: 2014 6 1 851 -9 1205 -5 0 AA #&gt; 2: 2014 6 1 1220 -10 1522 -13 0 AA #&gt; 3: 2014 6 1 718 18 1014 -1 0 AA #&gt; 4: 2014 6 1 1024 -6 1314 -16 0 AA #&gt; 5: 2014 6 1 1841 -4 2125 -45 0 AA #&gt; 6: 2014 6 1 1454 -6 1757 -23 0 AA #&gt; tailnum flight origin dest air_time distance hour min #&gt; 1: N787AA 1 JFK LAX 324 2475 8 51 #&gt; 2: N795AA 3 JFK LAX 329 2475 12 20 #&gt; 3: N784AA 9 JFK LAX 326 2475 7 18 #&gt; 4: N791AA 19 JFK LAX 320 2475 10 24 #&gt; 5: N790AA 21 JFK LAX 326 2475 18 41 #&gt; 6: N785AA 117 JFK LAX 329 2475 14 54 ans &lt;- flights[1:2] ans #&gt; year month day dep_time dep_delay arr_time arr_delay cancelled carrier #&gt; 1: 2014 1 1 914 14 1238 13 0 AA #&gt; 2: 2014 1 1 1157 -3 1523 13 0 AA #&gt; tailnum flight origin dest air_time distance hour min #&gt; 1: N338AA 1 JFK LAX 359 2475 9 14 #&gt; 2: N335AA 3 JFK LAX 363 2475 11 57 ans &lt;- flights[order(origin, -dest)] head(ans) #&gt; year month day dep_time dep_delay arr_time arr_delay cancelled carrier #&gt; 1: 2014 1 5 836 6 1151 49 0 EV #&gt; 2: 2014 1 6 833 7 1111 13 0 EV #&gt; 3: 2014 1 7 811 -6 1035 -13 0 EV #&gt; 4: 2014 1 8 810 -7 1036 -12 0 EV #&gt; 5: 2014 1 9 833 16 1055 7 0 EV #&gt; 6: 2014 1 13 923 66 1154 66 0 EV #&gt; tailnum flight origin dest air_time distance hour min #&gt; 1: N12175 4419 EWR XNA 195 1131 8 36 #&gt; 2: N24128 4419 EWR XNA 190 1131 8 33 #&gt; 3: N12142 4419 EWR XNA 179 1131 8 11 #&gt; 4: N11193 4419 EWR XNA 184 1131 8 10 #&gt; 5: N14198 4419 EWR XNA 181 1131 8 33 #&gt; 6: N12157 4419 EWR XNA 188 1131 9 23 ans &lt;- flights[, arr_delay] head(ans) #&gt; [1] 13 13 9 -26 1 0 ans &lt;- flights[, .(arr_delay, dep_delay)] head(ans) #&gt; arr_delay dep_delay #&gt; 1: 13 14 #&gt; 2: 13 -3 #&gt; 3: 9 2 #&gt; 4: -26 -8 #&gt; 5: 1 2 #&gt; 6: 0 4 ans &lt;- flights[, .(delay_arr = arr_delay, delay_dep = dep_delay)] head(ans) #&gt; delay_arr delay_dep #&gt; 1: 13 14 #&gt; 2: 13 -3 #&gt; 3: 9 2 #&gt; 4: -26 -8 #&gt; 5: 1 2 #&gt; 6: 0 4 flights[, sum((arr_delay + dep_delay) &lt; 0)] #&gt; [1] 141814 flights[origin == &quot;JFK&quot; &amp; month == 6L, .(m_arr = mean(arr_delay), m_dep = mean(dep_delay))] #&gt; m_arr m_dep #&gt; 1: 5.84 9.81 flights[origin == &quot;JFK&quot; &amp; month == 6L, length(dest)] #&gt; [1] 8422 flights[, .(.N), by = .(origin)] #&gt; origin N #&gt; 1: JFK 81483 #&gt; 2: LGA 84433 #&gt; 3: EWR 87400 flights[carrier == &quot;AA&quot;, .N, by = origin] #&gt; origin N #&gt; 1: JFK 11923 #&gt; 2: LGA 11730 #&gt; 3: EWR 2649 flights[carrier == &quot;AA&quot;, .N, by = .(origin,dest)] #&gt; origin dest N #&gt; 1: JFK LAX 3387 #&gt; 2: LGA PBI 245 #&gt; 3: EWR LAX 62 #&gt; 4: JFK MIA 1876 #&gt; 5: JFK SEA 298 #&gt; 6: EWR MIA 848 #&gt; 7: JFK SFO 1312 #&gt; 8: JFK BOS 1173 #&gt; 9: JFK ORD 432 #&gt; 10: JFK IAH 7 #&gt; 11: JFK AUS 297 #&gt; 12: EWR DFW 1618 #&gt; 13: LGA ORD 4366 #&gt; 14: JFK STT 229 #&gt; 15: JFK SJU 690 #&gt; 16: LGA MIA 3334 #&gt; 17: LGA DFW 3785 #&gt; 18: JFK LAS 595 #&gt; 19: JFK MCO 597 #&gt; 20: JFK EGE 85 #&gt; 21: JFK DFW 474 #&gt; 22: JFK SAN 299 #&gt; 23: JFK DCA 172 #&gt; 24: EWR PHX 121 #&gt; origin dest N flights[carrier == &quot;AA&quot;, .N, by = .(origin, dest)][order(origin, -dest)][1:10,] #&gt; origin dest N #&gt; 1: EWR PHX 121 #&gt; 2: EWR MIA 848 #&gt; 3: EWR LAX 62 #&gt; 4: EWR DFW 1618 #&gt; 5: JFK STT 229 #&gt; 6: JFK SJU 690 #&gt; 7: JFK SFO 1312 #&gt; 8: JFK SEA 298 #&gt; 9: JFK SAN 299 #&gt; 10: JFK ORD 432 "],
["ggplot.html", "6 보고용 차트를 위한 ggplot2 사용하기 6.1 ggplot2", " 6 보고용 차트를 위한 ggplot2 사용하기 6.1 ggplot2 # 패키지 불러오기 library(tidyverse) #&gt; + ggplot2 2.2.1 Date: 2017-08-20 #&gt; + tibble 1.3.3 R: 3.4.1 #&gt; + tidyr 0.6.3 OS: Windows 10 x64 #&gt; + readr 1.1.1 GUI: RTerm #&gt; + purrr 0.2.3 Locale: Korean_Korea.949 #&gt; + dplyr 0.7.2 TZ: Asia/Seoul #&gt; + stringr 1.2.0 #&gt; + forcats 0.2.0 #&gt; ─ Conflicts ────────────────────────── #&gt; * filter(), from dplyr, masks stats::filter() #&gt; * lag(), from dplyr, masks stats::lag() options(stringsAsFactors = F) # layers = data + mapping(aes) + geom + stat + position # ggplot = layers + scales + coordinate system # 데이터 설명 : https://github.com/jennybc/gapminder # 시각화 예시 : http://www.gapminder.org/tools/#_locale_id=en;&amp;chart-type=bubbles if (!require(&quot;gapminder&quot;)){install.packages(&quot;gapminder&quot;)} library(gapminder) # ggplot 객체 만들기 p &lt;-ggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) p # 객체의 구조와 정보 파악하기 summary(p) # geom 추가 하기 point p_point &lt;- p + geom_point() p_point # 객체 정보에서 geom이 추가된 것 확인하기 summary(p_point) # x 축을 log 변환하여 출력하기 ggplot(gapminder, aes(x = log10(gdpPercap), y = lifeExp)) + geom_point() # ggplot 문법에 맞게 log 변환하기 p_point_log10 &lt;- p_point + scale_x_log10() p_point_log10 # color 정보를 aes를 이용해서 mapping 하기 p_point_color &lt;- p + geom_point(aes(color = continent)) p_point_color # 색정보가 mapping 된 것 확인하기 summary(p_point_color) # geom 특징 조절하기 alpha = 투명도, size = 크기 p + geom_point(alpha = (1/3), size = 3) # 추세선 추가하기 # method가 자동으로 지정되나 설정할 수 있음 p_point + stat_smooth() # 추세선에 대해 geom으로도 취급함 # geom 특징인 선 두께(lwd)등 조절 가능 p_point + geom_smooth(lwd = 3, se = FALSE) # method를 lm(선형회귀)로 변경 p_point + geom_smooth(lwd = 2, se = FALSE, method = &quot;lm&quot;) # 색정보를 전체에 반형하기 p_point_color + geom_smooth(lwd = 2, se = FALSE) p + aes(color = continent) + geom_point() + geom_smooth(lwd = 1, se = FALSE) # group 과 color p + aes(color = continent) + geom_point() + geom_smooth(lwd = 2, se = FALSE) p + aes(group = continent)+ geom_point() + geom_smooth(lwd = 2, se = FALSE) # 그래프를 facet 기준으로 나눠 그리기 p + geom_point(alpha = (1/3), size = 3) + facet_wrap(~ continent) p + geom_point(alpha = (1/3), size = 3) + facet_wrap(~ continent) + geom_smooth(lwd = 2, se = FALSE) # jitter : 집중된 정보를 흩뿌려 보여주는 특별한 geom_point ggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) + geom_jitter(alpha = 1/3, size = 3, width=1) ggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) + geom_point(alpha = 1/3, size = 3) # 대륙별로 차트 나눠 그리기 ggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) + facet_wrap(~ continent) + geom_jitter(alpha = 1/3, size = 3, width=1) # 각 차트의 척도 기준 조절하기(default = &quot;fixed&quot;) ggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) + facet_wrap(~ continent, scales = &quot;free_y&quot;) + geom_jitter(alpha = 1/3, size = 3) # scale 함수로 색 조절하기 ggplot(gapminder, aes(x = year, y = lifeExp, color = continent)) + facet_wrap(~ continent, scales = &quot;free_x&quot;) + geom_jitter(alpha = 1/3, size = 3) + scale_color_manual(values = continent_colors) # dplyr 과 섞어 사용하기 # %&gt;% 와 + 주의 jc &lt;- &quot;Cambodia&quot; gapminder %&gt;% filter(country == jc) %&gt;% ggplot(aes(x = year, y = lifeExp)) + labs(title = jc) + geom_line() # point + line # 여러 기준의 point 출력하기 (lp &lt;- ggplot(gapminder, aes(x = year, y = lifeExp)) + geom_point()) # 대륙 기준 차트 나누기 lp + facet_wrap(~ continent) # 각 차트별 추세선 추가하기 lp + geom_smooth(se = FALSE, lwd = 2) + facet_wrap(~ continent) # geom은 각 개별이 layer이므로 추가됨 lp + geom_smooth(se = FALSE, lwd = 2) + geom_smooth(se = FALSE, method =&quot;lm&quot;, color = &quot;orange&quot;, lwd = 2) + facet_wrap(~ continent) # 객체 준비하기 lpf &lt;- lp + facet_wrap(~ continent) # geom_point 에 geom_line 추가하기 lpf + geom_line() # 각 line이 나라별 데이터이므로 group해야 함 lpf + geom_line(aes(group = country)) # 전체 데이터에 대해 추세선 추가 lpf + geom_line(aes(group = country)) + geom_smooth(se = FALSE, lwd = 2) # color가 group의 역할을 함. jCountries &lt;- c(&quot;Canada&quot;, &quot;Rwanda&quot;, &quot;Cambodia&quot;, &quot;Mexico&quot;) gapminder %&gt;% filter(country %in% jCountries) %&gt;% ggplot(aes(x = year, y = lifeExp, color = country)) + geom_line() + geom_point() # 범례 순서를 데이터의 순서로 재조정 gapminder %&gt;% filter(country %in% jCountries) %&gt;% ggplot(aes(x = year, y = lifeExp, color = reorder(country, -1 * lifeExp, max))) + geom_line() + geom_point() # bin2d 차트 ggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) + scale_x_log10() + geom_bin2d() # 헥사 차트 if (!require(&quot;hexbin&quot;)){install.packages(&quot;hexbin&quot;)} ggplot(gapminder, aes(x = gdpPercap, y = lifeExp)) + scale_x_log10() + geom_hex() + scale_fill_gradient(high = &quot;#132B43&quot;, low = &quot;#56B1F7&quot;) # 대륙별 관측치 개수 구하기 table(gapminder$continent) # histogram 그리기 ggplot(gapminder, aes(x = continent)) + geom_bar() # 크기순으로 재정렬 # reorder(정렬하고자 하는 대상, 정렬 기준, 정렬 조건) p &lt;- ggplot(gapminder, aes(x = reorder(continent, continent, length))) p + geom_bar() # coordinate 함수 중 돌리기 p + geom_bar() + coord_flip() # goem_bar 특징 조절하기 p + geom_bar(width = 0.1) + coord_flip() # length 를 계산해서 그래프 그리기 (continent_freq &lt;- gapminder %&gt;% count(continent)) # bar plot이 마음대로 그려지지 않음 (freq_plot &lt;- ggplot(continent_freq, aes(x = continent)) + geom_bar()) # stat이 count인 것을 확인(bar는 default가 count) summary(freq_plot) # 계산을 한 데이터로 bar plot 출력하는 법 (freq_ident&lt;-ggplot(continent_freq, aes(x = continent, y = n)) + geom_bar(stat = &quot;identity&quot;)) summary(freq_ident) # historam 옵션을 사용하기 ggplot(gapminder, aes(x = lifeExp)) + geom_histogram() # geom 조절하기 bin은 나누는 구간의 크기를 의미 ggplot(gapminder, aes(x = lifeExp)) + geom_histogram(binwidth = 1) # 각 대륙별로 나눠서 보기 (hist_fill&lt;-ggplot(gapminder, aes(x = lifeExp, fill = continent)) + geom_histogram()) # stack이 기본 옵션임(누적 그래프) summary(hist_fill) # 최대값이 독립적이 되게 작성 ggplot(gapminder, aes(x = lifeExp, fill = continent)) + geom_histogram(position = &quot;identity&quot;) # 밀도함수 - 선색 ggplot(gapminder, aes(x = lifeExp, color = continent)) + geom_density() # 밀도함수 - 면적 색 ggplot(gapminder, aes(x = lifeExp, fill = continent)) + geom_density(alpha = 0.2) # point에서 정보가 충분히 보이지 않을 때 ggplot(gapminder, aes(x = continent, y = lifeExp)) + geom_point() # jitter 흩뿌리기 ggplot(gapminder, aes(x = continent, y = lifeExp)) + geom_jitter() # jitter geom 조절하기 ggplot(gapminder, aes(x = continent, y = lifeExp)) + geom_jitter(position = position_jitter(width = 0.1, height = 0), alpha = 1/4) # boxplot 평균 및 4분위 표시 ggplot(gapminder, aes(x = continent, y = lifeExp)) + geom_boxplot() # layer 겹치게 그리기 ggplot(gapminder, aes(x = continent, y = lifeExp)) + geom_boxplot(outlier.colour = &quot;hotpink&quot;) + geom_jitter(position = position_jitter(width = 0.1, height = 0), alpha = 1/4) # stat 기능으로 layer 추가하기 ggplot(gapminder, aes(x = continent, y = lifeExp)) + geom_jitter(position = position_jitter(width = 0.1), alpha = 1/4) + stat_summary(fun.y = median, colour = &quot;red&quot;, geom = &quot;point&quot;, size = 5) ## korean map ## UTM / UTM-K / GPS ## 좌표계에 대한 설명 # https://mrchypark.wordpress.com/2014/10/23/%EC%A2%8C%ED%91%9C%EA%B3%84-%EB%B3%80%ED%99%98-proj4-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/ # 패키지 세팅하기 if (!require(&quot;mapdata&quot;)){install.packages(&quot;mapdata&quot;)} if (!require(&quot;mapproj&quot;)){install.packages(&quot;mapproj&quot;)} library(mapdata) library(mapproj) # 내장된 지도 데이터 불러와서 한국만 가져오기 world&lt;-map_data(&quot;worldHires&quot;) korea&lt;-world[grep(&quot;Korea$&quot;, world$region),] # 한국 지도 그리기 p&lt;-ggplot(korea,aes(x=long,y=lat,group=group)) p+geom_polygon(fill=&quot;white&quot;,color=&quot;black&quot;) + coord_map() # Kormaps를 이용해 세부적인 한국 지도 그리기 # 패키지 세팅하기 if (!require(&quot;Kormaps&quot;)){devtools::install_github(&quot;cardiomoon/Kormaps&quot;)} if (!require(&quot;tmap&quot;)){install.packages(&quot;tmap&quot;)} if (!require(&quot;cartogram&quot;)){devtools::install_github(&quot;sjewo/cartogram&quot;)} library(Kormaps) library(tmap) library(cartogram) # 윈도우를 위한 폰트 설정하기 # for windows windowsFonts() if (!require(&quot;extrafont&quot;)){install.packages(&quot;extrafont&quot;)} library(extrafont) #font_import() loadfonts() # 내장 인구 데이터를 이용해 한국 지도 그리기 qtm(kormap1) qtm(korpopmap1,&quot;총인구_명&quot;)+tm_layout(fontfamily=&quot;NanumGothic&quot;) qtm(korpopmap2,&quot;총인구_명&quot;)+tm_layout(fontfamily=&quot;NanumGothic&quot;) # 인코딩 문제 고치기 Encoding(names(korpopmap1))&lt;-&quot;UTF-8&quot; Encoding(names(korpopmap2))&lt;-&quot;UTF-8&quot; # ggplot 으로 한국 지도 그리기 위한 전처리 kor &lt;- fortify(korpopmap1, region = &quot;id&quot;) kordf &lt;- merge(kor, korpopmap1@data, by = &quot;id&quot;) # ggplot으로 한국 지도 그리기 ggplot(kordf, aes(x=long.x, y=lat.x, group=group.x, fill=`총인구_명`)) + geom_polygon(color=&quot;black&quot;) + coord_map() + scale_fill_gradient(high = &quot;#132B43&quot;, low = &quot;#56B1F7&quot;) + theme(title=element_text(family=&quot;NanumGothic&quot;,face=&quot;bold&quot;)) # ggplot facet 기능 적용해 보기 # 남녀 인구로 구분 kordfs &lt;- kordf %&gt;% select(id:여자_명) %&gt;% gather(성별,인구,-(id:총인구_명)) # 남녀 인구 한국 지도 시각화 ggplot(kordfs, aes(x=long.x, y=lat.x, group=group.x, fill=`인구`)) + geom_polygon(color=&quot;black&quot;) + coord_map() + scale_fill_gradient(high = &quot;#132B43&quot;, low = &quot;#56B1F7&quot;) + theme(text=element_text(family=&quot;NanumGothic&quot;,face=&quot;bold&quot;)) + facet_grid(.~ 성별) # 2016년 총선 결과 cartogram 그리기 # https://www.facebook.com/groups/krstudy/permalink/785465478294393/기 # cartogram의 다른 예시(ggplot 아님) # https://github.com/jjangkr/cartogram_4_anything library(rgdal) library(maptools) korea &lt;- readOGR(dsn = &quot;./election&quot;, layer=&quot;DistResult2016&quot;, encoding = &#39;euc-kr&#39;) # sp패키지의 SpatialPolygonsDataFrame 자료형을 사용합니다. class(korea) # 카토그램 모양을 계산합니다. 시간이 꽤 걸리니 5이하의 숫자를 사옹해 주세요. # 지금은 미리 만든 객체를 불러올 것입니다. # c_korea &lt;- cartogram(korea, &quot;Pop&quot;, 5) # save(c_korea,file = &quot;c_korea.RData&quot;) load(&quot;c_korea.RData&quot;) # data.frame으로 변환하기 위해 fortify 함수를 사용합니다. c_korea.df &lt;- fortify(c_korea) # 변환된 상태 class(c_korea.df) head(c_korea.df) summary(c_korea.df) str(c_korea.df) # 데이터를 합치기 위한 키 생성 c_korea@data$id &lt;- rownames(c_korea@data) # 데이터 합치기 - 조인 c_korea.df &lt;- c_korea.df %&gt;% left_join(c_korea@data, by=&quot;id&quot;) str(c_korea.df) # 인코딩 수정 Encoding(c_korea.df$Dist)&lt;-&quot;UTF-8&quot; Encoding(c_korea.df$SD)&lt;-&quot;UTF-8&quot; Encoding(c_korea.df$SGG)&lt;-&quot;UTF-8&quot; str(c_korea.df) # 빈 테마 미리 만들기 theme_clean &lt;- function(base_size = 12) { require(grid) theme_grey(base_size) %+replace% theme( axis.title = element_blank(), axis.text = element_blank(), panel.background = element_blank(), panel.grid = element_blank(), axis.ticks.length = unit(0, &quot;cm&quot;), complete = TRUE ) } # 카토그램 그리기 election &lt;- ggplot(c_korea.df, aes(x=long, y=lat, group=group)) + geom_polygon(aes(alpha=RatioS), fill=rgb(1,0,0), colour=&quot;white&quot;, lwd = 0.01) + geom_polygon(aes(alpha=RatioP), fill=rgb(0,1,0), colour=&quot;white&quot;, lwd = 0.01) + geom_polygon(aes(alpha=RatioT), fill=rgb(0,0,1), colour=&quot;white&quot;, lwd = 0.01) + guides(fill=FALSE, alpha=FALSE) + theme_clean() + coord_map() election # ggmap # https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/ggmap/ggmapCheatsheet.pdf devtools::install_github(&quot;dkahle/ggmap&quot;) library(ggmap) # for mac loc&lt;-&quot;서울&quot; tar&lt;-&quot;서울시청&quot; # for windows loc&lt;-URLencode(enc2utf8(&quot;서울&quot;)) tar&lt;-URLencode(enc2utf8(&quot;서울시청&quot;)) # output = c(&quot;latlon&quot;, &quot;latlona&quot;, &quot;more&quot;, &quot;all&quot;) # 위경도만 / +주소 / +나라,우편번호등 추가 / + api 정보 전체 geocityhall&lt;-geocode(tar) get_googlemap(loc,maptype = &quot;roadmap&quot;,markers = geocityhall) %&gt;% ggmap() ## extra ## https://www.ggplot2-exts.org/ ## ggplot을 더 풍부하게 만들어 주는 추가 패키지 소개 # ggsci # https://cran.r-project.org/web/packages/ggsci/vignettes/ggsci.html # 유명 색조합이 미리 준비되어 있는 패키지 devtools::install_github(&quot;road2stat/ggsci&quot;) library(ggsci) library(gridExtra) data(&quot;diamonds&quot;) # 그래프 객체 저장하기 p1 = ggplot(subset(diamonds, carat &gt;= 2.2), aes(x = table, y = price, colour = cut)) + geom_point(alpha = 0.7) + geom_smooth(method = &quot;loess&quot;, alpha = 0.05, size = 1, span = 1) + theme_bw() p2 = ggplot(subset(diamonds, carat &gt; 2.2 &amp; depth &gt; 55 &amp; depth &lt; 70), aes(x = depth, fill = cut)) + geom_histogram(colour = &quot;black&quot;, binwidth = 1, position = &quot;dodge&quot;) + theme_bw() # aaas 테마 적용하기 p1_aaas = p1 + scale_color_aaas() p2_aaas = p2 + scale_fill_aaas() # grid.arrange는 gridExtra 패키지내 함수입니다. grid.arrange(p1_aaas, p2_aaas, ncol = 2) p1_aaas p1 + theme_hc() + scale_colour_hc() # ggthemes # 테마 추가 devtools::install_github(&quot;jrnold/ggthemes&quot;) library(&quot;ggthemes&quot;) p1_th1&lt;-p1 + theme_hc() + scale_colour_hc() p2_th2&lt;-p2 + theme_hc(bgcolor = &quot;darkunica&quot;) + scale_fill_hc(&quot;darkunica&quot;) grid.arrange(p1_th1, p2_th2, ncol = 2) # ggrepel # https://github.com/slowkow/ggrepel/blob/master/vignettes/ggrepel.md # 글자를 겹치지 않게 그려주는 패키지 devtools::install_github(&quot;slowkow/ggrepel&quot;) library(ggrepel) # 차트에 글자 추가하기 ggplot(mtcars) + geom_point(aes(wt, mpg), color = &#39;red&#39;) + geom_text(aes(wt, mpg, label = rownames(mtcars))) + theme_classic(base_size = 16) # 차트에 글자가 겹치지 않게 추가하기 ggplot(mtcars) + geom_point(aes(wt, mpg), color = &#39;red&#39;) + geom_text_repel(aes(wt, mpg, label = rownames(mtcars))) + theme_classic(base_size = 16) # ggExtra # https://github.com/daattali/ggExtra # 3면 차트를 그리게 도와주는 패키지 devtools::install_github(&quot;daattali/ggExtra&quot;) library(ggExtra) df1 &lt;- data.frame(x = rnorm(500, 50, 10), y = runif(500, 0, 50)) (p1 &lt;- ggplot(df1, aes(x, y)) + geom_point() + theme_bw()) ggMarginal(p1, type = &quot;histogram&quot;) # ggfortify # https://github.com/sinhrks/ggfortify # 분석 결과 보고용 출력 수준 차트 생성 패키지 1 devtools::install_github(&#39;sinhrks/ggfortify&#39;) library(ggfortify) # 자동으로 분석 결과에 맞는 그림 출력하기 # k-means 클러스터링 res &lt;- lapply(c(3, 4, 5), function(x) kmeans(iris[-5], x)) autoplot(res, data = iris[-5], ncol = 3) # 회귀 분석 autoplot(lm(Petal.Width ~ Petal.Length, data = iris), data = iris, colour = &#39;Species&#39;, label.size = 3) if (!require(&quot;dlm&quot;)){install.packages(&quot;dlm&quot;)} library(dlm) form &lt;- function(theta){ dlmModPoly(order = 1, dV = exp(theta[1]), dW = exp(theta[2])) } # 동적선형분석 model &lt;- form(dlmMLE(Nile, parm = c(1, 1), form)$par) filtered &lt;- dlmFilter(Nile, model) autoplot(filtered) # ggally # http://ggobi.github.io/ggally/index.html # 분석 결과 보고용 출력 수준 차트 생성 패키지 2 devtools::install_github(&quot;ggobi/ggally&quot;) if (!require(&quot;network&quot;)){install.packages(&quot;network&quot;)} if (!require(&quot;sna&quot;)){install.packages(&quot;sna&quot;)} library(network) library(sna) library(GGally) airports &lt;- read.csv(&quot;http://datasets.flowingdata.com/tuts/maparcs/airports.csv&quot;, header = TRUE) rownames(airports) &lt;- airports$iata # 무작위로 일부 비행기만 선택 flights &lt;- data.frame( origin = sample(airports[200:400, ]$iata, 200, replace = TRUE), destination = sample(airports[200:400, ]$iata, 200, replace = TRUE) ) # network 자료형으로 변환 flights &lt;- network(flights, directed = TRUE) # 위경도 정보 추가 %v%는 각 노드 정보라는 뜻의 연산자 flights %v% &quot;lat&quot; &lt;- airports[ network.vertex.names(flights), &quot;lat&quot; ] flights %v% &quot;lon&quot; &lt;- airports[ network.vertex.names(flights), &quot;long&quot; ] flights # 혼자 있는 노드 제거 delete.vertices(flights, which(degree(flights) &lt; 2)) # 중심성 계산 flights %v% &quot;degree&quot; &lt;- degree(flights, gmode = &quot;digraph&quot;) # 랜덤으로 4개의 집단으로 구분 flights %v% &quot;mygroup&quot; &lt;- sample(letters[1:4], network.size(flights), replace = TRUE) # 미국지도만 생성 usa &lt;- ggplot(map_data(&quot;usa&quot;), aes(x = long, y = lat)) + geom_polygon(aes(group = group), color = &quot;grey65&quot;, fill = &quot;#f9f9f9&quot;, size = 0.2) # 미국내 정보 이외에 제거 delete.vertices(flights, which(flights %v% &quot;lon&quot; &lt; min(usa$data$long))) delete.vertices(flights, which(flights %v% &quot;lon&quot; &gt; max(usa$data$long))) delete.vertices(flights, which(flights %v% &quot;lat&quot; &lt; min(usa$data$lat))) delete.vertices(flights, which(flights %v% &quot;lat&quot; &gt; max(usa$data$lat))) # 미국 지도 위에 비행기 layer 추가하기 ggnetworkmap(usa, flights, size = 4, great.circles = TRUE, node.group = mygroup, segment.color = &quot;steelblue&quot;, ring.group = degree, weight = degree) # gganimate # http://www.gapminder.org/world/ # 움직이는 차트 그리기 devtools::install_github(&quot;dgrtwo/gganimate&quot;) if (!require(&quot;magick&quot;)){install.packages(&quot;magick&quot;)} library(magick) library(gganimate) # for mac # brew install ghostscript imagemagick # for ubuntu # sudo apt-get install ghostscript imagemagick # for windows # http://www.imagemagick.org/script/binary-releases.php # https://www.ghostscript.com/download/gsdnld.html p &lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, color = continent, frame = year)) + geom_point() + scale_x_log10() p # for windows magickPath &lt;- shortPathName(&quot;C:\\\\Program Files\\\\ImageMagick-7.0.5-Q16\\\\magick.exe&quot;) animation::ani.options(convert=magickPath) gganimate(p,interval = .2) dir.create(&quot;./animate&quot;,showWarnings = F) gganimate(p, &quot;./animate/output.gif&quot;) gganimate(p, &quot;./animate/output.mp4&quot;) gganimate(p, &quot;./animate/output.html&quot;) # ggiraph # http://davidgohel.github.io/ggiraph/ # javescript 기반 동적 차트 생성 패키지 devtools::install_github(&quot;davidgohel/ggiraph&quot;) library(ggiraph) # 기본 그래프 그리기 g &lt;- ggplot(mpg, aes( x = displ, y = cty, color = hwy) ) + theme_minimal() g + geom_point(size = 2) # 폰트가 여기서 나오지 않으면 ggiraph가 출력되지 않습니다. gdtools::sys_fonts() # if data NUll try below for mac # brew install cairo # tooltip 기능을 활용한 동적 차트 예 my_gg &lt;- g + geom_point_interactive(aes(tooltip = model), size = 2) ggiraph(code = print(my_gg), width = .7) # ggedit # gui 클릭으로 ggplot 컨트롤할 수 있게 해주는 add-on install.packages(&quot;ggedit&quot;) library(ggedit) p &lt;- ggplot(mtcars, aes(x = hp, y = wt)) + geom_point() + geom_smooth(method = &#39;loess&#39;) p ggedit(p) ## extrafont 한글 깨짐 + 폰트 변경을 위한 패키지 "],
["knitr.html", "7 정기 보고서 자동 작성을 위해 knitr로 문서화하고 스케줄러로 자동화하기 7.1 Markdown 문법 7.2 Rmd 양식으로 문서 작성 7.3 스케줄러 7.4 bookdown", " 7 정기 보고서 자동 작성을 위해 knitr로 문서화하고 스케줄러로 자동화하기 7.1 Markdown 문법 7.1.1 마크다운이란 마크다운이란 plain text를 쉽게 일정 양식의 문서로 바꿀 수 있게 간단한 규칙을 정해 놓은 것을 말합니다. 문서의 디자인을 결정하는 요소는 발달 과정에 따라 html을 대표로 일정 표준이 만들어지고 관리되고 있습니다. html과 css는 웹페이지가 어떻게 보이는지를 결정하는 문법으로 구성되어 있습니다. html은 문서를 구조화하여 같은 상태로 둘 요소들을 같은 상태로 표기하는 것이고, css는 그 같은 조건에 있는 것들을 같은 모양으로 보이게, 모양을 작성하는 문서입니다. 그렇기 때문에 html의 요소들을 잘 정의했으면, css에 따라 마치 테마가 바뀌는 것처럼 따라 바꿀 수 있게 됩니다. 그 중 문서에 필요한 최소한의 markdown 규칙을 commonmark에서 지정을 했구요. 너무 단순한 규칙 때문에 매우 많은 확장 문법들이 각자의 방식으로 발전했습니다. 특히 오픈소스의 발달로 소스에 대한 설명 등이 plain text 양식으로, README 라는 이름의 파일로 남기는 것이 관례가 되었습니다. 소스 관리 저장소 서비스를 운영하는 github 같은 곳에서는 웹으로 서비스를 제공하고 있고, 이 plain text를 예쁘게 보여주기 위해서 markdown문법을 채택했으며 각 서비스 들이 각자 추가적인 문법을 제공하고 있는 중입니다. 현재 0.27버전이 정리가 되었고 이곳에서 확인하실 수 있습니다. 7.1.2 문법 소개 markdown이 down인 만큼 html에서 구조화를 위해 사용하는 요소들을 사용할 수 있습니다. 제목 : # , ===== 인용 : &gt; 강조 : * , _ 링크 : [텍스트](주소 &quot;설명 생략가능&quot;) 이미지 : ![텍스트](이미지주소 &quot;설명 생략가능&quot;) 리스트 : 1 , * , - , + 코드표시 : &lt;code&gt;코드&lt;/code&gt; , 한줄 띄우고 스페이스 4칸 , ```코드``` 줄바꿈 : 엔터 2번 , 강제 줄바꿈은 문장끝에 스페이스바 2칸 가로선 : ----- , ***** , +++++ 7.1.2.1 제목 #이 표시가 html에서는 &lt;h1&gt; 태그와 같습니다. &lt;h&gt;는 총 6까지 있으며 #표시는 숫자를 쓰는게 아니라 # 갯수로 수를 표현합니다. # 제목1 : HTML의 &lt;h1&gt; 태그 ## 제목2 : HTML의 &lt;h2&gt; 태그 ### 제목3 : HTML의 &lt;h3&gt; 태그 #### 제목4 : HTML의 &lt;h4&gt; 태그 ##### 제목5 : HTML의 &lt;h5&gt; 태그 ###### 제목6 : HTML의 &lt;h6&gt; 태그 7.1.2.2 인용 인용은 인용 속에 인용, 인용 속에 인용이 가능한 구조입니다. 보통 왼쪽에 세로줄이 있는 형태로 뫼부에 보여줍니다. &gt; ### 제일 바깥의 인용 &gt;&gt; ** 인용의 인용 ** 7.1.2.2 제일 바깥의 인용 ** 인용의 인용 ** 7.1.2.3 blod &amp; italic 강조하는 방식은로는 * 이나 _의 갯수로 결정납니다. 이것은 **굵은 글씨** 입니다. 이것은 __굵은 글씨__ 입니다. 이것은 *기울여 쓰기* 입니다. 이것은 _기울여 쓰기_ 입니다. 이것은 ***강조하며 기울여 쓰기*** 입니다. 이것은 ___강조하며 기울여 쓰기___ 입니다. 이것은 굵은 글씨 입니다. 이것은 굵은 글씨 입니다. 이것은 기울여 쓰기 입니다. 이것은 기울여 쓰기 입니다. 이것은 강조하며 기울여 쓰기 입니다. 이것은 강조하며 기울여 쓰기 입니다. 7.1.2.4 links 바로가기 링크를 페이지상에 바로 구현할 수 있습니다. 링크를 바로 옆에 작성하는 방식과 주석처럼 다는 2가지 방식이 있습니다. 앞에서 사용한 방식을 인라인 방식이라고 하고, 뒤에 방식을 레퍼런스 방식이라고 합니다. 이것은 [링크](http://www.example.com) 입니다. 이것은 [링크](http://www.example.com &quot;설명문구 생략가능&quot;) 입니다. 이것은 [구글 링크][1] 입니다. 이것은 [마이크로소프트 링크][b] 입니다. 이것은 [애플 링크][three] 입니다. [1]: https://www.google.co.kr &quot;구글&quot; [b]: https://www.microsoft.com/ko-kr/ &quot;마이크로소프트&quot; [three]: http://www.apple.com/kr/ &quot;애플&quot; 이것은 링크 입니다. 이것은 링크 입니다. 이것은 구글 링크 입니다. 이것은 마이크로소프트 링크 입니다. 이것은 애플 링크 입니다. 7.1.2.5 image 이미지를 첨부하는 방법은 마우스를 사용하는 방식이 아니라서 좀 불편할 수 있습니다. 앞서 바로가기 링크를 만드는 것과 같은 방식인데 앞에 !를 추가해서 작성합니다. 이미지는 실제로 문서에서 해당 링크의 이미지를 가져와서 문서에서 보여주는 방식입니다. 이미지의 위치나 크기 같은 것을 조정하기 위해서는 기본 markdown 문법에서는 제공하지 않습니다. 그래서 관련 문법을 제공하는 서비스를 사용하거나 html 문법이나 css 를 사용해야 합니다. 1. ![깃헙](https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/GitHub_logo_2013.svg/225px-GitHub_logo_2013.svg.png &quot;설명문구 생략가능&quot;) 2. ![깃허브][imgGithub] [imgGithub]: https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/GitHub_logo_2013.svg/225px-GitHub_logo_2013.svg.png &quot;설명문구 생략가능&quot; &lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/GitHub_logo_2013.svg/225px-GitHub_logo_2013.svg.png&quot; width=&quot;200&quot;&gt; 7.1.2.6 number 앞에 숫자를 붙여서 작업하고 싶을 때가 있습니다. 1. 를 앞에 입력하시면 들여쓰기가 같은 줄에 따라 숫자를 붙여줍니다. 숫자를 자유롭게 사용하셔도 순서대로 작업해주니 보통 1로만 작성하는 것 같습니다. 들여쓰기는 4칸 띄어쓰기를 의미합니다. 1. 번호1 1. 번호2 1. 번호1 1. 번호2 1. 번호3 1. 번호3 1. 번호3 9. 번호5 번호1 번호2 번호1 번호2 번호3 번호3 번호3 번호 9 7.1.2.7 list 숫자 붙이는 것과 같이 앞에 동그라미 표시 등을 통해서 간결한 문체로 작성할 때가 있습니다. 들여쓰기로 3단까지 다른 모양을 자동으로 보여줍니다. * 리스트 * * 리스트 * - 리스트 - * 리스트 * - 리스트 - * 리스트 * - 리스트 - - 리스트 - - 리스트 - 리스트 * 리스트 * 리스트 - 리스트 * 리스트 - 리스트 * 리스트 - 리스트 - 리스트 - 7.1.2.8 코드 코드는 복사하기 좋고, 텍스트 그대로를 문서에 남길때 사용합니다. 위에 복사를 위한 글자들 모두 코드를 작성하는 양식으로 작성하였습니다. 아래에는 코드 안에 내용을 보이게 하기위해서 앞에 &quot;를 붙여서 작성했습니다. souce를 직접 확인해 보시면 좋습니다. &quot; ``` 코드 &quot; ``` 코드 7.1.2.9 수식 LaTex는 수식을 입력하는 규칙이 규정되어 있습니다. 이를 활용해서 $$ 수식문법 $$ 의 규칙으로 복잡한 수식을 작성할 수 있습니다. 수식문법에 대해서는 좋은 포스트를 공유하니 추가적으로 필요하신 분들은 공부해보시면 좋을 것 같습니다. $$ \\left|\\sum_{i=1}^n a_ib_i\\right| \\le \\left(\\sum_{i=1}^n a_i^2\\right)^{1/2} \\left(\\sum_{i=1}^n b_i^2\\right)^{1/2} $$ \\[ \\left|\\sum_{i=1}^n a_ib_i\\right| \\le \\left(\\sum_{i=1}^n a_i^2\\right)^{1/2} \\left(\\sum_{i=1}^n b_i^2\\right)^{1/2} \\] 7.2 Rmd 양식으로 문서 작성 rmarkdown는 위에서 설명한 markdown문법을 활용하여 R의 명령문과 조합해서 문서를 작성하기 위한 하나의 양식입니다. 공식 홈페이지는 이곳이고 소스는 이 곳을 확인하시면 됩니다. 한글 cheatsheet도 있고, rstudio &gt; help &gt; cheatsheet 에도 cheatsheet과 reference가 있습니다. rmarkdown 패키지는 Rmd 양식의 문서를 knitr과 pandoc으로 다양한 문서양식으로 생성해주는 패키지입니다. proccess knitr은 rmd양식의 문서 중 R엔진의 처리가 필요한 계산과 이미지 생성등의 작업을 자동화하여 md의 문법과 위치에 맞게 md문서를 생성해 줍니다. 그리고 pandoc이 YAML양식의 해더 정보를 바탕으로 다른 포멧의 저작물로 변환해주는 것입니다. 변환 가능한 저작물로는 notebook, html, pdf, word, odt등의 문서와 ioslides, reveal.js, Slidy, Beamer의 슬라이드, 대쉬보드, 웹페이지, 책 등 입니다. 본 자료에서는 md와는 다르게 동작하는 rmd의 특수 문법들과 옵션을 알아보고, 각 문서형으로 변환하는 작업에 대해서 알아보겠습니다. 7.2.1 R code 실행 결과 Rmd의 가장 강력한 점은 코드의 결과를 옮겨적거나 따로 저장해서 고쳐내지 않고, 최종 결과물을 코드에서 바로 작성할 수 있다는 점입니다. Rmd의 R 코드 실행시 변환해주는 내용은 아래 5가지 입니다. if(!require(knitr)) install.packages(&quot;knitr&quot;) #&gt; 필요한 패키지를 로딩중입니다: knitr library(knitr) obj&lt;-c(&quot;소스코드&quot;,&quot;텍스트&quot;,&quot;플롯&quot;,&quot;메세지&quot;,&quot;경고&quot;) role&lt;-c(&quot;코드청크에 들어있는 R 코드&quot;, &quot;summary(iris)와 같은 글자 출력 결과물&quot;, &quot;plot(iris)와 같은 그림 출력 결과물&quot;, &quot;메세지&quot;,&quot;경고&quot;) dat&lt;-data.frame(&quot;객체&quot;=obj,&quot;목적&quot;=role) kable(dat,align=&quot;cl&quot;) 객체 목적 소스코드 코드청크에 들어있는 R 코드 텍스트 summary(iris)와 같은 글자 출력 결과물 플롯 plot(iris)와 같은 그림 출력 결과물 메세지 메세지 경고 경고 코드 작성 방식은 inline과 chunk 방식으로 나뉩니다. inline은 글들과 함께 중간에 들어가는 것을 뜻하고, chunk는 말 그대로 코드 덩어리 째로 들어가서 위의 6가지를 출력할 것인지 말것인지의 옵션에 따라 결과물을 보여줍니다. 7.2.1.1 line R code 글자들 사이에 만약 항상 문서를 생성하는 시점의 날짜로 지정하고 싶다면 아래와 작성하면 됩니다. 본 문서는 2017-08-20 에 작성되었습니다. 소스를 확인해서 어떻게 작성했는지 확인해보세요. 7.2.1.2 code chunk chunk는 덩어리라는 뜻 답게 코드가 실행되는 하나의 단위입니다. Rmd은 컴퓨터에 설치만 되어 있다면 다른 언어들도 chunk내의 실행 결과를 변환해서 md파일로 바꿔줍니다. R과 다른 점은 각 chunk별로 독립적인 프로세스를 실행시키기 때문에 변수들이 chunk 사이에서 함께 사용할 수 없습니다. 원래 코드를 작성하는 방식인 ```의 사이에 code를 작성하면 되는데 윗줄의 표시 뒤에 {R}을 작성하면 R 엔진으로 실행시킬 코드라는 사실을 knitr의 렌더링 함수가 이해하게 됩니다. 7.2.1.2.1 출력 옵션들 위에 5개 내용에 대해서 fig.cap을 빼고 모두 TRUE/FALSE로 출력할지 말지 조정할 수 있습니다. echo : 코드 include : 코드와 글자 출력물 fig.cap : 그림 출력물 message : 메세지 warning : 경고 각 옵션은 chuck에게 R로 처리함을 알려주는 {R} 안에 작성합니다. 앞에 &quot;는 제거해야 합니다. &quot;```{r echo=T} &quot;```{r echo=T, message=F} &quot;```{r echo=T, message=F,warning=F} fig.cap은 그림 출력물의 가로 세로 길이나 위치 등의 옵션을 조정할 수 있습니다. 7.2.2 YAML 해더를 이용한 출력물 7.2.2.1 YAML 해더 Rmd 초기 설명에 잠깐 언급한 YAML 해더에 대해서 설명하겠습니다. 이것에 따라서 html, word 등 출력 결과물을 조절할 수 있습니다. --- title: 테스트 해더 author: 박찬엽 date: 2017년 5월 output: html_document --- 첫 양식인 html을 하기 위해서는 위와 같이 output 옵션을 html_document로 지정하면 됩니다. 그러면 해더 정보를 바탕으로 html 문서로 변환을 해줍니다. html 문서로 변환하는 것의 가장 큰 장점은 역시 동적 문서 형식을 유지할 수 있다는 점입니다 PDF나 word는 정적 문서이기 때문에 제한 된 기능으로만 출력물을 저장할 수 있습니다. Rmd에 동적 출력 결과물이 code상에 실행하도록 되어 있다면 PDF나 word로 변환시 에러를 일으킵니다. webshot은 본래 웹페이지를 기계적으로 스크린샷하기 위해 작성된 패키지인데, 문서중 동적인 요소들을 스크린샷해서 반영해주는 동작을 해줍니다. 특별히 해더에 정보를 추가해서 디자인이나 테마를 변경할 수 있습니다. html은 이미 많은 style을 미리 지정해두고 이름만으로 사용할 수 있게 되어있습니다. style에서 지정해볼 수 있는 다른 테마들을 찾아보세요. --- title: 테스트 해더 author: 박찬엽 date: 2017년 5월 output: html_document: theme: flatly --- css를 추가하려면 아래와 같이 작성합니다. --- title: 테스트 해더 author: 박찬엽 date: 2017년 5월 output: html_document: css: css/customStyle.css --- 위와 같이 작성하고 css 오른쪽에 디자인에 해당하는 css 파일의 경로를 지정해주면 됩니다. 7.2.2.2 YAML params YAML이 데이터 양식이라고 설명을 드렸습니다. 그래서 Rmd내부에서 접근할 수 있는 데이터를 params라는 이름으로 미리 작성해 둘 수 있습니다. 지금은 inline 코드를 양쪽에 -로 처리 했습니다. --- title: -r params$chapter- 테스트 해더 params: chapter: 5 author: 박찬엽 date: 2017년 5월 output: html_document: css: css/customStyle.css --- 해더 내 양식으로 보여드리려고 위와 같이 작성했지만 Rmd 문서 모든 code 작성 공간에서 같은 양식으로 값에 접근할 수 있습니다. 7.2.2.3 word 문서로 만들기 Rmd는 word 문서로도 변환할 수 있습니다. 위에서 설명한 html_document 위치에 word_document 라고 입력하면 됩니다. word에서는 스타일을 word문서에서 참조하는 방법이 있어 소개하려고 합니다. 7.2.2.3.1 reference docx 사용하기 우선 Rmd를 word 출력물로 설정해서 새로 만듭니다. 그리고 knit 버튼을 이용해 우선 docx 확장자의 word 문서를 만듭니다. 그냥 새 파일을 만들수도 있지만, 호환이 잘 안되는 경우도 있어서 안전한 방법을 설명했습니다. 만들어진 워드 파일을 새로운 이름으로 바꿔 저장합니다. 이번 예시에서는 style.docx로 저장했습니다. 저장된 style.docx 파일을 열어서 스타일 정보를 수정합니다. 확인하셔야 할 부분은 수정해야될 정보가 스타일이지, 각 텍스트 들의 디자인이 아니라는 점입니다. 스타일 정보를 YAML 해더에 아래와 같이 입력해 줍니다. --- title: 워드 스타일 테스트 해더 author: 박찬엽 date: 2017년 5월 output: word_document: reference_docx: style.docx --- 파일의 경로는 Rmd 파일이 있는 폴더의 위치가 working diractory라고 인식하므로 같은 곳에 있으면 추가적인 경로 작성 없이 위와 같이 파일 이름만 작성해 주면 됩니다. word_style.Rmd에 가능한 한 보이는 양식들을 넣은 기본 문서로 작성했으니 이 것으로 word문서를 생성후 스타일 파일로 사용하시면 좋을 것 같습니다. 7.2.2.4 PDF 문서로 만들기 PDF 문서로 만들 때는 위에 잠시 나왔던 LaTex이 설치되어 있어야 합니다. 이곳에서 각자의 운영체제에 맞게 다운 받아 설치하시면 됩니다. linux는 기본 설치 되어 있을 텐데 콘솔에서 latex을 입력해보시면 됩니다. 없으면 debian 계열 sudo apt-get install texlive, Centos 계열 sudo yum install tetex로 설치할 수 있습니다. PDF는 word_document 부분을 pdf_document라고 하면 됩니다. ?pdf_document를 입력해서 설정할 수 있는 것이 무엇이 있는지 확인해 보세요. 한글 때문에 폰트 및 추가로 설정해야 하는 부분이 있습니다. 여기와 여기를 참고하세요. 7.3 스케줄러 운영체제에 포함되어 있는 스케줄러란 일정한 시간이나 조건에 반복적으로 작업을 수행하게 해주는 프로그램입니다. 어떤 언어에서든 계속적인 작업을 위해서 스케줄러를 사용하는데, 아래는 대표적으로 사용하는 스케줄러를 소개하고 있습니다. 특히 환경변수라고 하는 부분에 대해서 rstudio의 작업환경과 조금 다르고, 분리해서 생각해야 할 부분이 있어서 조금 골치 아프기도 합니다. 운영체제에 특화되서 사용하기도 합니다. 윈도우는 내장되어 있는 작업 스케줄러, 리눅스 계열과 mac은 전통적으로 cron을 사용하고 있습니다. 서버에 일을 시키기 위해서 cron을 사용하는 방법을 익히는 것은 매우 중요한 것 같습니다. 7.3.1 windows 작업 스케줄러 윈도우는 실행 파일을 정해진 시간에 자동으로 실행시켜주는 task scheduler가 있습니다. 이것을 컨트롤하는 패키지인 taskscheduleR가 있어서 함께 사용해 보겠습니다. 7.3.2 linux 작업 스케줄러 cron 또한 위와 같은 cronR이 있습니다. 사용하는 모양이 같으니 한번 사용해 보겠습니다. 두 가지 모두 rstudio를 관리자 권한으로 실행시켜줘야 합니다. 7.4 bookdown 지금 보시는 자료를 만들때 사용한 패키지인 bookdown입니다. 들어가 보시면 R 관련한 제작자들이 직접 만든 다양한 자료들이 있습니다. 패키지를 설명하는 책이 가장 위에 있으면서 사례로 확인하실 수 있습니다. 처음부터 우수 사례를 패키지 홍보으로 활용한 매우 사례라고 생각합니다. 처음 6권과 더불어 필요에 따라 네트워크 분석을 주제로 하는 Social Network Analysis in Education도 참고하기 매우 좋은 내용 같습니다. 여기 패키지는 현재의 강의자료 소스를 활용해 작업을 완료하고, 각자 github을 통해서 호스팅을 하는 것 까지 실습하도록 하겠습니다. "],
["shiny.html", "8 shiny 패키지를 활용한 인터렉티프 웹 만들기 8.1 shiny 8.2 shiny의 입출력 8.3 encoding 문제 8.4 shiny가 지원하는 js 패키지들의 활용", " 8 shiny 패키지를 활용한 인터렉티프 웹 만들기 8.1 shiny shiny는 데이터 분석 시각화 도구인 R을 사용해서 한걸음 더 나아가 웹 어플리케이션을 제작할 수 있게 해주는 패키지 입니다. 웹 사이트라고도 할 수 있을 것 같은데요, 그래서 shiny를 잘 사용하기 위해서는 웹 어플리케이션 제작에 대한 사전 지식이 있는 것이 매우 도움이 됩니다. 하지만 없다고 해서 어렵다기 보단, 디테일한 제작을 위해서는 조금 더 공부하면 좋다 정도로 보시면 될 것 같습니다. 우선 shiny는 ui라고 불리는 화면, server라고 불리는 데이터 처리 및 관리, 그 안에 입출력과 render와 배포로 구성되어 있습니다. 8.1.1 shiny의 화면 ui라고 말하는 화면은 실제로 사용자가 보는 화면을 뜻합니다. shiny에서는 크게 titlePanel과 sidebarPanel, mainPanal의 세 가지로 구성되어 있습니다. 이렇게 지정함으로써 html에 대해 잘 몰라도 사용할 수 있게 shiny가 구성되어 있습니다. 8.1.2 shiny의 서버 shiny에서의 server는 실제 서버가 브라우저와 통신하는 과정 전체를 간단하게 만들어주는 역할을 합니다. 화면에서 사용자가 동작하는 것에 대해서 받을 수 있는 input을 서버에서 데이터나 그림 조작에 사용을 하고 웹 기술이 이해할 수 있게 render하여 output으로 화면에 다시 보내주는 형태로 shiny가 동작합니다. 8.1.3 shiny의 입출력 shiny는 다른 R 패키지와는 다르게 강제하는 변수가 3개 있습니다. 그것은 input, output, session 입니다. 각각 객체로써 존재하고 이번에는 input과 output으로 데이터를 ui와 server가 교환하는 방법을 소개하겠습니다. 각각의 객체는 *Input 함수와 *Output 함수로 데이터를 입력 받아 저장합니다. *Output 함수는 render* 함수로 선언됩니다. 8.1.4 shiny의 배포 shiny는 shiny-server를 통해서 동작합니다. shiny-server는 shiny app이 동작할 수 있는 서버를 의미합니다. 오픈소스와 기업용 솔루션이 모두 준비되어 있으며 실습에는 http://www.shinyapps.io/를 이용해 보겠습니다. 8.2 shiny의 입출력 shiny는 웹 기술을 R로 사용할 수 있게 만드는 덕분에 render라는 과정이 필요합니다. 그래서 render 환경에서 변수들이 관리되어야 합니다. 입출력은 input 변수와 output 변수로 관리합니다. 이 두 가지는 render 밖에서 관리되는 변수로 다르게 취급해야 합니다. 8.2.1 output$ output 변수는 list라고 이해하시면 좋을 것 같습니다. list인 output 변수는 output$뒤에 변수명을 작성함으로써 output 객체에 필요한 결과물을 전달합니다. 만약에 화면에 보여줘야할 것의 이름을 sample이라고 하면 output$sample에 필요한 내용을 선언하는 것으로 진행합니다. ... output$sample &lt;- randerPlot({ ...plot()... }) ... 위 코드는 server쪽 코드에서 작성합니다. 위 예시는 plot함수로 만들어지는 이미지를 output$sample에 저장하는 것을 뜻합니다. 그럼 ui쪽에서 이걸 어디에다 위치하게 하는지를 결정하는 함수에서 사용할 수 있습니다. 이때는 plotOutput 함수를 사용합니다. ... plotOutput(&quot;sample&quot;) ... 함수명이 Output 이고, &quot;로 변수명을 감싸며, output$ 문법을 사용하지 않고 컬럼명인 sample만 사용한다는 점을 주목해 주세요. server쪽 코드에서 output$에 컬럼명의 형태로 저장한 R의 결과물을 ui쪽 코드에서 *Output 함수에서 &quot;로 감싼 글자의 형태로 컬럼명만 작성해서 사용합니다. 그럼 이제 위해서 output$sample에 선언할 때 사용한 render*({})에 대해서 알아보겠습니다. 8.2.2 render*({}) Rmd 때 render라는 과정을 거쳐서 Rmd를 md로, md를 html로 바꾸는 것을 알아봤었습니다. shiny에서도 같은 과정이 필요합니다. 그래서 render*({ })함수가 필요합니다. 예시로 보겠습니다. ... output$sample &lt;- randerPlot({ plot(faithful) }) ... render*({ }) 함수 안에는 plot 함수가 R 문법으로 작성되어 있습니다. 그리고 render*({ })의 특이한 점은 () 안에 {}가 또 있다는 점입니다. 여기서는 ({ }) 안쪽은 R의 세계이고, 그 바깥은 웹의 세계라고 이해하겠습니다. 그래서 이런게 가능합니다. ... output$sample &lt;- randerPlot({ data &lt;- faithful[faithful$eruptions &gt;3, ] plot(data) }) ... R의 세계 내에서 처리하는 것은 계속 사용할 수 있어서 data 변수에 선언한 내용을 plot함수가 사용할 수 있습니다. 여기서 input$이 활용될 때 반응형으로 작성할 수 있는 것입니다. 8.2.3 input$ intput$은 output$과 같이 웹의 세계에 있는 변수입니다. 그래서 *Input() 함수들을 통해서 input$의 컬럼 이름으로 웹 페이지 내에서 얻을 수 있는 데이터를 R의 세계에서 사용할 수 있게 해줍니다. 우선 input$에 웹의 세계의 데이터를 R의 세계로 가져와 보겠습니다. sliderInput(&quot;sdata1&quot;, &quot;슬라이더 입력:&quot;, min=50, max=150, value=100) 위의 코드는 sliderInput()이라는 *Input() 패밀리 함수를 통해서 input$sdata1이라는 곳에 웹 데이터를 저장하는 것을 뜻합니다. *Input() 패밀리 함수는 같은 규칙을 가지는데 입력형태명Input()의 함수명을 가지고, 첫번째 인자는 input$ 뒤로 붙을 컬럼명, 두번째 인자는 화면에 보여줄 글자를 의미합니다. 나머지 인자는 입력형태에 따라 다양하게 달라집니다. shiny에서 지원하는 입력형태는 이곳을 확인해 주세요. 8.2.4 shiny 앱 작성 구조 이제 input하나를 받고 output 하나를 출력하는 shiny 앱을 작성할 준비가 되었습니다. 이제 간단한 sample을 통해 작성된 코드를 확인해 보고 같이 작성을 진행해 보겠습니다. shiny는 그 복잡함 때문에 여러 사례를 풍부하게 제공하는 몇 안되는 패키지 입니다. 사례 참고만 잘 하셔도 멋진 반응형 웹을 만들 수 있습니다. library(shiny) #&gt; 필요한 패키지를 로딩중입니다: methods runExample() #&gt; Valid examples are &quot;01_hello&quot;, &quot;02_text&quot;, &quot;03_reactivity&quot;, &quot;04_mpg&quot;, &quot;05_sliders&quot;, &quot;06_tabsets&quot;, &quot;07_widgets&quot;, &quot;08_html&quot;, &quot;09_upload&quot;, &quot;10_download&quot;, &quot;11_timer&quot; library(rvest) #&gt; 필요한 패키지를 로딩중입니다: xml2 url&lt;-&quot;https://github.com/rstudio/shiny-examples&quot; tem&lt;- read_html(url) fold&lt;-tem %&gt;% html_nodes(&quot;tr td span a.js-navigation-open&quot;) %&gt;% html_text cnt &lt;- grep(&quot;^[0-9]&quot;,fold) %&gt;% length 위 코드는 실행해 볼 수 있는 예제를 보여줍니다. 아래처럼 실행하시면 바로 실행되는 shiny 앱 예제를 확인하 실 수 있습니다. shiny github에는 예제 repo가 있고, 활용할 수 있는 예제는 2017-08-20 기준 110개 입니다. runExample(&quot;01_hello&quot;) 위를 실행해 보시면 아래와 같은 화면이 나옵니다. 예제는 코드도 함께 볼 수 있게 되어 있어서 공부하기 좋습니다. 우선 서버쪽 부터 보겠습니다. # shiny 패키지를 불러옵니다. library(shiny) # server를 function으로 선언합니다. 웹의 세계에서 사용할 변수는 input과 output 입니다. function(input, output) { # 웹의 세계의 변수인 output에 list 컬럼인 distPlot을 선언합니다. # 그 선언을 renderPlot({})으로 해서 distPlot이 plot()으로 작성한 그림이라는 것을 이해합니다. # renderPlot({ ... }) 함수 안에 R의 세계에서 hist() 함수의 결과가 나오게 작성합니다. # 이때 input$bin으로 웹에서 사용자가 주는 데이터를 활용할 것입니다. # bin은 경계라는 뜻으로 연속형 변수를 histogram을 그릴 때 얼마나 구간을 나눌 것인지를 결정합니다. # ?hist를 통해 어떤 그림을 그리는 함수인지를 확인해 보세요. # ?seq를 통해 어떤 결과물을 만드는 함수인지 확인해 보세요. output$distPlot &lt;- renderPlot({ x &lt;- faithful[, 2] # Old Faithful Geyser data bins &lt;- seq(min(x), max(x), length.out = input$bins + 1) # draw the histogram with the specified number of bins hist(x, breaks = bins, col = &#39;darkgray&#39;, border = &#39;white&#39;) }) } 위에 코드에서 input$bins가 render*({}) 함수 안에서 사용됬습니다. output$은 웹의 세계에서 사용하지만 input$은 R의 세계에서 사용합니다. 이부분은 reactive({}) 함수에서 추가적으로 다루기로 하겠습니다. 이제 ui쪽 코드를 확인해 보겠습니다. shiny-example-02 # shiny 패키지를 불러옵니다. ibrary(shiny) # fluidPage는 shiny의 페이지를 보여주는 핵심 기능입니다. titlePanel, sidebarPanal, mainPanel로 구성되어 있습니다. # titlePanel은 제목을 작성하는 곳입니다. # sidebarPanel은 전체 화면을 3등분해서 왼쪽을 뜻합니다. # mainPanel은 전체 화면을 3등분해서 오른쪽을 뜻합니다. fluidPage( # Application title titlePanel(&quot;Hello Shiny!&quot;), # Sidebar with a slider input for the number of bins sidebarLayout( sidebarPanel( sliderInput(&quot;bins&quot;, &quot;Number of bins:&quot;, min = 1, max = 50, value = 30) ), # Show a plot of the generated distribution mainPanel( plotOutput(&quot;distPlot&quot;) ) ) ) shiny의 전체 화면 구성 기능은 이곳를 참고하세요. 그리고 이것은 bootstrap을 사용하여 만들었습니다. 그래서 bootstrap의 화면 구성에 대한 개념을 이해하시면 더 쉽게 다양한 세부 조작이 가능합니다. fluid라고 작성하는 모든 부분은 화면의 크기에 반응하여 적절하게 변화한다는 뜻입니다. bootswatch에서 제공하는 테마를 바로 적용해서 사용할 수 있습니다. fluidPage(theme = &quot;Journal&quot;, titlePanel(&quot;태마를 바꿀 수 있습니다.&quot;) ) 이제 코드를 다시 보면 sliderInput을 통해서 input$bins 데이터를 웹의 세상에서 받아오는 것을 볼 수있습니다. 지금 기본 값으로 30을 기록해 두었지만, 웹의 세상에서 변화시켜주는 것에 따라 input$bins의 데이터가 변해서 server에서 input$bins의 형태로 그 데이터를 사용할 수 있습니다. 웹의 세상이나 R의 세상이란 말은 정확한 표현은 아니지만 이해를 돕기 위해서 활용했습니다. 그리고 ui에서는 웹의 세계로 나온 output$distPlot을 plotOutput() 함수로 웹 페이지에 위치시킬 수 있습니다. output$distPlot은 현재 mainPanel에 위치해 있네요. 위치의 세부적인 조정은 이곳을 참고하세요. shiny는 대부분의 html tag를 지원합니다. html에 대한 사전 지식이 있으시면 활용하시는데 도움이 됩니다. 추가적인 내용은 이곳을 참고하세요. names(tags) #&gt; [1] &quot;a&quot; &quot;abbr&quot; &quot;address&quot; &quot;area&quot; &quot;article&quot; #&gt; [6] &quot;aside&quot; &quot;audio&quot; &quot;b&quot; &quot;base&quot; &quot;bdi&quot; #&gt; [11] &quot;bdo&quot; &quot;blockquote&quot; &quot;body&quot; &quot;br&quot; &quot;button&quot; #&gt; [16] &quot;canvas&quot; &quot;caption&quot; &quot;cite&quot; &quot;code&quot; &quot;col&quot; #&gt; [21] &quot;colgroup&quot; &quot;command&quot; &quot;data&quot; &quot;datalist&quot; &quot;dd&quot; #&gt; [26] &quot;del&quot; &quot;details&quot; &quot;dfn&quot; &quot;div&quot; &quot;dl&quot; #&gt; [31] &quot;dt&quot; &quot;em&quot; &quot;embed&quot; &quot;eventsource&quot; &quot;fieldset&quot; #&gt; [36] &quot;figcaption&quot; &quot;figure&quot; &quot;footer&quot; &quot;form&quot; &quot;h1&quot; #&gt; [41] &quot;h2&quot; &quot;h3&quot; &quot;h4&quot; &quot;h5&quot; &quot;h6&quot; #&gt; [46] &quot;head&quot; &quot;header&quot; &quot;hgroup&quot; &quot;hr&quot; &quot;html&quot; #&gt; [51] &quot;i&quot; &quot;iframe&quot; &quot;img&quot; &quot;input&quot; &quot;ins&quot; #&gt; [56] &quot;kbd&quot; &quot;keygen&quot; &quot;label&quot; &quot;legend&quot; &quot;li&quot; #&gt; [61] &quot;link&quot; &quot;mark&quot; &quot;map&quot; &quot;menu&quot; &quot;meta&quot; #&gt; [66] &quot;meter&quot; &quot;nav&quot; &quot;noscript&quot; &quot;object&quot; &quot;ol&quot; #&gt; [71] &quot;optgroup&quot; &quot;option&quot; &quot;output&quot; &quot;p&quot; &quot;param&quot; #&gt; [76] &quot;pre&quot; &quot;progress&quot; &quot;q&quot; &quot;ruby&quot; &quot;rp&quot; #&gt; [81] &quot;rt&quot; &quot;s&quot; &quot;samp&quot; &quot;script&quot; &quot;section&quot; #&gt; [86] &quot;select&quot; &quot;small&quot; &quot;source&quot; &quot;span&quot; &quot;strong&quot; #&gt; [91] &quot;style&quot; &quot;sub&quot; &quot;summary&quot; &quot;sup&quot; &quot;table&quot; #&gt; [96] &quot;tbody&quot; &quot;td&quot; &quot;textarea&quot; &quot;tfoot&quot; &quot;th&quot; #&gt; [101] &quot;thead&quot; &quot;time&quot; &quot;title&quot; &quot;tr&quot; &quot;track&quot; #&gt; [106] &quot;u&quot; &quot;ul&quot; &quot;var&quot; &quot;video&quot; &quot;wbr&quot; 8.2.5 반응형 함수들 위에서 shiny 코드들을 소개할 때 웹의 세상과 R의 세상으로 설명한 부분이 기억나실 겁니다. 이것은 웹의 세상의 데이터를 R의 세상으로 데려와서 여러 처리에 사용하고, 결과를 다시 웹의 세상으로 보내는 과정을 설명하면서 사용했습니다. 이 때 input$은 R의 세상에 있었고, output$은 웹의 세상에 있었습니다. render*({})함수를 통해서 R의 세상의 결과물을 output$에 전달한다고도 했구요. 이 과정에서 render*({}) 함수는 목적이 결과물을 전달하는데 있습니다. input$을 이용해서 계산하는 과정이 간단한 것들은 render*({}) 함수 내부에 포함되어도 큰 문제가 되지 않지만, 계산을 여러 output$에서 사용한다면 고치는 것을 고려해 볼 수있습니다. 개발에서는 반복되는 부분을 최대한 줄이거나 합치려는 경향이 있는데 2가지 장점이 있습니다. 하나는 효율화가 가능하구요, 다른 하나는 가독성이 좋아집니다. 우선 겹쳐서 사용하는 사례를 보겠습니다. library(shiny) ui&lt;-fluidPage( titlePanel(&quot;test&quot;), sidebarPanel( selectInput(&quot;dataSelect&quot;,&quot;데이터셋 선택 :&quot;, choices=list(&quot;mtcars&quot;,&quot;sleep&quot;,&quot;iris&quot;,&quot;co2&quot;)) ), mainPanel( verbatimTextOutput(&quot;out1&quot;), verbatimTextOutput(&quot;out2&quot;) ) ) server&lt;-function(input, output){ output$out1 &lt;- renderPrint({ summary(get(input$dataSelect)) }) output$out2 &lt;- renderPrint({ str(get(input$dataSelect)) }) } shinyApp(ui,server) ?get으로 어떤 동작을 하는 함수인지 확인하세요. 데이터셋을 불러오는 역할을 하는데, renderPrint({})가 두 번 있으면서 get함수가 각각 실행되어 같은 연산을 두 번하는 효과가 발생하였습니다. 그렇다면 그 동작을 한번만 하게끔 바꿔보겠습니다. library(shiny) ui&lt;-fluidPage( titlePanel(&quot;test&quot;), sidebarPanel( selectInput(&quot;dataSelect&quot;,&quot;데이터셋 선택 :&quot;, choices=list(&quot;mtcars&quot;,&quot;sleep&quot;,&quot;iris&quot;,&quot;co2&quot;)) ), mainPanel( verbatimTextOutput(&quot;out1&quot;), verbatimTextOutput(&quot;out2&quot;) ) ) server&lt;-function(input, output){ selectedData&lt;-get(input$dataSelect) output$out1 &lt;- renderPrint({ summary(selectedData) }) output$out2 &lt;- renderPrint({ str(selectedData) }) } shinyApp(ui,server) get함수로 데이터를 부르는 부분을 앞으로 빼내고, 선언한 selectedData를 summary와 str함수로 사용하였습니다. 실행해 보시면 에러가 나는 것을 확인할 수 있습니다. 웹의 세상에서 R의 세상 문법으로 작성해서 생기는 문제인데요. 에러코드를 함께 보겠습니다. Error in .getReactiveEnvironment()$currentContext() : Operation not allowed without an active reactive context. (You tried to do something that can only be done from inside a reactive expression or observer.) reactive context라는게 눈에 띄는데요. 이것이 R의 세상 문법이 동작하는 공간입니다. selectedData&lt;-get(input$dataSelect) 위에 코드는 R 문법으로 이루어져 있는데, 이것을 웹의 세상에서 작성했기 때문에 생기는 것이죠. 그럼 R의 세상 문법으로 작성할 수 있게 render*({})와 같은 환경을 제공하는 함수를 사용해 보겠습니다. library(shiny) ui&lt;-fluidPage( titlePanel(&quot;test&quot;), sidebarPanel( selectInput(&quot;dataSelect&quot;,&quot;데이터셋 선택 :&quot;, choices=list(&quot;mtcars&quot;,&quot;sleep&quot;,&quot;iris&quot;,&quot;co2&quot;)) ), mainPanel( verbatimTextOutput(&quot;out1&quot;), verbatimTextOutput(&quot;out2&quot;) ) ) server&lt;-function(input, output){ selectedData&lt;-reactive({ get(input$dataSelect) }) output$out1 &lt;- renderPrint({ summary(selectedData()) }) output$out2 &lt;- renderPrint({ str(selectedData()) }) } shinyApp(ui,server) reactive({})는 그 내부를 R의 세상으로 만듬으로써 선언 받는 변수를 함수화하여 반응형 데이터의 특성을 유지한채로 R의 세상에서 사용할 수 있게 해줍니다. 함수화라는 부분을 잘 보셔야 하는데, selectedData가 변수가 아니라 뒤에 ()가 붙은 함수라는 사실을 확인하세요. 웹의 세상에 있는 selectedData는 변수를 선언한 것이 아니라 R의 세상에서 사용할 수 있게 함수화하여 함수로써 선언하였습니다. 이런 R의 세상과 웹의 세상을 넘나드는 부분을 관장하는 함수에는 render*({}), reactive({}), isolate({}), observeEvent({}), eventReactive({}), reactiveValues({}), observe({})가 있습니다. 앞에 두 개는 예시를 들어 설명을 했구요. isolate({}) 은 즉각적인 반응이 아니라 어떤 다른 사용자의 입력(ex&gt; action 버튼)을 인지하여 그 때 input에 해당하는 부분을 확인하여 결과물을 만듭니다. render*({})함수 내부에서 사용합니다. observeEvent({})와 eventReactive({})는 위에 처럼 어떤 input을 인지하여 동작합니다. observeEvent({})는 서버 부분에서 실행해야 할 것들을 담당하기 때문에 선언의 형태가 아니라 독립적으로 작성됩니다. 예를 들어 서버에 파일을 저장한다거나, 로그로 남기는 글자를 출력하거나 할 때 사용합니다. eventReactive({})는 reactive({})와 같이 웹의 세상의 변수에 선언하면서 함수화하여 R의 세상에서 반응형 데이터로써 사용할 수 있습니다. reactiveValues({})는 input$이나 output$과 같은 역할을 하는 변수를 만드는 함수입니다. observe({})는 observeEvent({})와 eventReactive({})의 근간이 되는 함수로, input$의 입력을 인지하는 역할을 합니다. 8.3 encoding 문제 이곳를 참고하세요. 이런 문제의 대부분은 중국어도 같이 가지고 있어서 중국쪽의 해결책이 많이 도움이 됩니다. 일본어 역시 마찬가지입니다. 8.4 shiny가 지원하는 js 패키지들의 활용 8.4.1 지도를 지원하는 leaflet leaflet은 javascript 언어로 이루어진 지도에 대한 패키지입니다. shiny는 htmlwidget을 이용해서 javascript를 R로 변환하여 사용하는 것이 매우 많습니다. leaflet 역시 마찬가지로 이곳에 상세한 코드 예시들과 함께 소개가 준비되어 있습니다. 8.4.2 마우스 이벤트를 추가적으로 지원하는 ggiraph ggiraph는 ggplot의 geom계 함수들에게 뒤에 _interactive를 붙여 활용함으로써 조금더 표가 사용자와 상호작용 할 수 있는 부분을 추가해줍니다. 효과로는 click, hover, zoom, data_id 등이 있습니다. 8.4.3 상호작용 network 화면을 만드는 visNetwork visNetwork는 네트워크 시각화를 위한 패키지로 상호작용에 대해 유연하게 작성할 수 있게 설계되었습니다. node와 edge, group에 대한 개념만 이해하시면 멋진 네트워크 시각화 화면을 만들어 볼 수 있습니다. 8.4.4 dashboard를 shiny로 만들어 보자 shinydashboard shinydashboard는 대쉬보드를 shiny로 제작할 수 있게 대쉬보드 제작 프레임워크인 AdminLTE을 기반으로 작성했습니다. 유료 템플릿을 판매하는 기반을 가진 오픈소스인 만큼 프레임워크의 질이 product ready 수준이라 사용하기 매우 좋습니다. "],
["eba788ecb998eba9b0.html", "마치며", " 마치며 "]
]
